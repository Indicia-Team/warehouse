<?php
/**
 * Indicia, the OPAL Online Recording Toolkit.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/gpl.html.
 *
 * @package Indicia
 * @subpackage Libraries
 * @author  Indicia Team
 * @license http://www.gnu.org/licenses/gpl.html GPL
 * @link    http://code.google.com/p/indicia/
 */

/**
* <h1>Report provider</h1>
* <p>The report provider allows for accession of predefined or provided reports.</p>
*
* @package Indicia
* @subpackage Controller
* @license http://www.gnu.org/licenses/gpl.html GPL
* @author Nicholas Clarke <xxx@xxx.net> / $Author$
* @copyright xxxx
* @version $Rev$ / $LastChangedDate$
*/

/**
* Class to control accession to reports generated by the Indicia core.
*
* A report will have a number of parameters that need to be completed by the requester. Because
* this interface is designed to be used by both the core module and the site module, we cannot
* directly request this information. As such, we do the following:
* <ol>
* <li> Grab the report and parse it for parameters. </li>
* <li> Cache the report (if it didn't exist on the server already) and assign it a unique id,
* which we store temporarily in the Kohana cache. </li>
* <li> Send a response back to the requester, inviting them to fill in the parameters. This
* reponse will include the id generated in step 3. </li>
* <li> The requester sends back the requested parameters, which are checked against the cache to
* ensure they're all there. If not, repeat these steps. </li>
* <li> The core retrieves the report from cache, merges the parameters in and executes the query
* against the core database. Results are formatted and returned to the requester. </li>
* </ol>
*
* We should also allow submission of parameters with the report, or a combination of this and
* requesting them as we go.
*
* We use XML reports roughly in keeping with the standard defined in Recorder (though with limited
* complexity compared to recorder's options). However, this module is written to easily allow
* reports written in other formats, and in keeping with the rest of the project we use JSON as our
* principal language for network communication - e.g. for parameter requests, delivery, and other
* messages.
*/

class ReportEngine {

  private $report;
  private $reportFormat;
  private $response;
  private $query;
  private $reportReader;
  // Of the form name => array('type' => type, 'display' => display, 'description' => desc)
  private $expectedParams;
  private $providedParams;
  private $localReportDir;
  private $cache;
  const rowsPerUpdate = 50;
  private $websiteIds;
  private $userId = null;
  private $sharingMode='reporting';

  /**
   * @var array A list of additional columns identified from custom attribute parameters.
   */
  private $attrColumns = array();
  
  /**
   * @var array A list of the actual custom attributes, along with a link to the cols they include.
   */
  private $customAttributes = array();
  
  /**
   * @var array A list mappings from known custom attribute captions to the IDs.
   */
  private $customAttributeCaptions = array();

  public function __construct($websiteIds = null, $userId = null)
  {
    $this->websiteIds = $websiteIds;
    $this->userId = $userId;
    $this->localReportDir = Kohana::config('indicia.localReportDir');
    $this->reportDb = new Database('report');
  }
  
  /** 
   * Retrieve all available reports, as a nested associative array.
   */
  public function report_list() {
    $reports = $this->internal_report_list(Kohana::config('indicia.localReportDir'), '/');
    foreach (Kohana::config('config.modules') as $path) {
      if (is_dir("$path/reports")) 
        $reports = array_merge_recursive($reports, $this->internal_report_list("$path/reports", '/'));
    }
    return $reports;
  }

  private function internal_report_list($root, $path) {
    $files = array();
    $fullPath = "$root$path";
    if (!is_dir($fullPath))
      throw new Exception("Failed to open reports folder ".$fullPath);
    $dir = opendir($fullPath);
    
    while (false !== ($file = readdir($dir))) {
      if ($file != '.' && $file != '..' && $file != '.svn' && is_dir("$fullPath$file"))
        $files[$file] = array('type'=>'folder','content'=>$this->internal_report_list($root, "$path$file/"));
      elseif (substr($file, -4)=='.xml') {
        $metadata = XMLReportReader::loadMetadata("$fullPath$file");
        $file = basename($file, '.xml');
        $reportPath = ltrim("$path$file", '/');
        $files[$file] = array('type'=>'report','title'=>$metadata['title'],'description'=>$metadata['description'], 'path'=>$reportPath);
      }
    }
    closedir($dir);
    return $files;
  }

  /**
  * Access the report - probably we will use routing to direct /report directly to /report/access
  * We can specify a request in a number of ways:
  * <ul>
  * <li> Predefined report on the core module. </li>
  * <li> Predefined report elsewhere (URI given). </li>
  * <li> Report passed with the query. </li>
  * </ul>
  * We also need to perform authentication at a read level for the data we're trying to access
  * (this might be fun, given the low level that the reports run at).
  *
  * @param string $report Name of the report file to run.
  * @param string $reportSource Source of the report, either local or remote.
  * @param string $reportFormat Format of the report file. Currently only xml report file formats are supported.
  * @param array $params Associative array of report parameters.
  */
  public function requestReport($report = null, $reportSource = 'local', $reportFormat = null,  $params = array())
  {
    $this->reportFormat = $reportFormat;
    $this->providedParams = array_merge(
      array('training' => 'false'),
      $params
    );
    // is the default sharing mode of "reporting" being overridden?
    if (isset($this->providedParams['sharing']))
      $this->sharingMode = $this->providedParams['sharing'];
    Kohana::log('debug', "Received request for report: $report, source: $reportSource");
    if ($reportSource == null) {
      $reportSource='local';
    }
    if ($report == null)
    {
      return array
      (
      'error' => 'Report parameter is null',
      'report' => $report,
      'source' => $reportSource
      );
    }

    switch ($reportSource)
    {
      case 'local':
        $this->fetchLocalReport($report);
        break;
      case 'remote':
        $this->fetchRemoteReport($report);
        break;
      case 'provided':
        $this->fetchProvidedReport($report);
        break;
      default:
        // ERROR
        return array('error' => 'Invalid report source specified');
    }

    // Now we switch based on the report format.
    switch ($this->reportFormat)
    {
      case 'xml':
        $this->reportReader = new XMLReportReader($this->report, $this->websiteIds, $this->sharingMode);
        $this->reportReader->loadStandardParams($this->providedParams, $this->sharingMode);
        break;
      default:
        return array('error' => 'Unknown report format specified: '. $this->reportFormat);
        // No known report specified - return some error
        // TODO
    }
    // What parameters do we expect?
    $this->expectedParams = $this->reportReader->getParams();
    // some have defaults in the report XML file
    $this->providedParams = array_merge($this->reportReader->defaultParamValues, $this->providedParams);
    // Pull out special case params for limit and offset
    $this->limit = isset($this->providedParams['limit']) ? $this->providedParams['limit'] : null;
    $this->offset = isset($this->providedParams['offset']) ? $this->providedParams['offset'] : null;
    $this->orderby = isset($this->providedParams['orderby']) ? $this->providedParams['orderby'] : null;
    $this->sortdir = isset($this->providedParams['sortdir']) ? $this->providedParams['sortdir'] : null;
    return array(
      'description' => $this->reportReader->describeReport(ReportReader::REPORT_DESCRIPTION_BRIEF),
      'content' => $this->compileReport()
    );
  }

  public function resumeReport($uid = null, $params = array())
  {

    if ($uid == null || $params == null)
    {
      $err = array
      (
      'error' => 'Trying to resume a report but one or more of params or uid is null',
      'uid' => $uid,
      'params' => $params
      );
      return $err;

    }

    // Retrieve the report from cache
    if (!$this->retrieveCachedReport($uid))
    {
      // Error here - the cached report has expired
      // TODO
    }

    // Merge the new parameters in
    $this->limit = isset($this->providedParams['limit']) ? $this->providedParams['limit'] : $this->limit;
    $this->offset = isset($this->providedParams['offset']) ? $this->providedParams['offset'] : $this->offset;
    $this->orderby = isset($this->providedParams['orderby']) ? $this->providedParams['orderby'] : $this->orderby;
    $this->sortdir = isset($this->providedParams['sortdir']) ? $this->providedParams['sortdir'] : $this->sortdir;

    return array(
      'description' => $this->reportReader->describeReport(ReportReader::REPORT_DESCRIPTION_BRIEF),
      'content' => $this->compileReport()
    );
  }

  /**
  * Checks parameters and returns request if they're not all there, else compiles the report.
  *
  * @return array Array containing columns and data.
  */
  private function compileReport()
  {
    // Do we need any more parameters?
    $unpopulatedParams = array_diff_key($this->expectedParams, $this->providedParams);
    if (isset($this->providedParams['paramsFormExcludes'])) {
      $includedParams = array_diff_key($this->expectedParams, 
          array_fill_keys(json_decode($this->providedParams['paramsFormExcludes']), ''), 
          // never ask for params with defaults in the params form.
          $this->reportReader->defaultParamValues);
    }
    if (!empty($unpopulatedParams))
    {
      // We need more parameters, so cache the report (and any existing parameters), get an id for
      // it and send a request for the others back to the requester.
      $uid = $this->cacheReport();

      // Send a request for further parameters back to the client. If the request specified the list of parameters to drop
      // in the paramsFormExcludes parameter, then the list of parameters is always the ones that are not excluded. Else
      // the list of parameters is the list of unpopulated parameters.
      $res = array('parameterRequest' => isset($includedParams) ? $includedParams : $unpopulatedParams, 'uid' => $uid);
      return $res;

    }
    else
    {
      // Okay, all the parameters have been provided.
      $this->mergeQuery();
      if ($this->limit===0 || $this->limit==='0' || (isset($_REQUEST['wantRecords']) && $_REQUEST['wantRecords']===0)) {
        // optimisation for zero limited queries
        $data=array();
      }
      else {
        $this->mergeCountQuery();
        $this->executeQuery();
        $data = $this->response->result_array(FALSE);
      }
      $this->prepareColumns();
      $this->post_process($data);
      $r = array(
        'columns'=>$this->columns,
        'records'=>$data
      );
      if (isset($includedParams) && count($includedParams)>0)
        $r['parameterRequest'] = $includedParams;
      return $r;
    }
  }
  
  public function record_count() {
    if (isset($this->countQuery) && $this->countQuery!==null) {
      $count = $this->reportDb->query($this->countQuery)->result_array(FALSE);
      // query could return no rows, in which case return zero.
      if(count($count)>0) return $count[0]['count'];
      return 0;
    } else {
      return false;
    }
  }
  
  /**
   * Obtain the set of columns from the report reader on demand, so it is only called once.
   */
  private function prepareColumns() {
    if (!isset($this->columns)) {
      $this->columns = array_merge(
         $this->reportReader->getColumns(),
         $this->attrColumns
      );
    }
  }
  /**
   * Takes the data and columns lists, and carries out any post query processing.
   * This includes vague date processing, and any other defined by the
   * report reader.
   */
  private function post_process(&$data) {
    $this->merge_attribute_data($data, $this->providedParams);

    $vagueDateProcessing = $this->getVagueDateProcessing();
    $downloadProcessing = $this->getDownloadDetails();
    if($vagueDateProcessing) {
      $this->add_vague_dates($data);
    }
    if($downloadProcessing->mode == 'INITIAL' || $downloadProcessing->mode == 'CONFIRM' ||$downloadProcessing->mode == 'FINAL') {
      $this->setDownloaded($data, $downloadProcessing);
    }
  }

  private function getVagueDateProcessing() {
    $vagueDateProcessing = $this->reportReader->getVagueDateProcessing();
    foreach ($this->providedParams as $name => $value) {
      if (!is_array($value))
        $vagueDateProcessing = preg_replace("/#$name#/", $value, $vagueDateProcessing);
    }
    return !($vagueDateProcessing == 'false');
  }

  private function getDownloadDetails() {
    $downloadProcessing = $this->reportReader->getDownloadDetails();
    foreach ($this->providedParams as $name => $value) {
      if (!is_array($value))
        $downloadProcessing->mode = preg_replace("/#$name#/", $value, $downloadProcessing->mode);
    }
    return $downloadProcessing;
  }


  /**
   * Takes the data and columns lists, and looks for a vague date column set.
   * If one is found, inserts a new column for the processed date string.
   */
  private function add_vague_dates(&$data) {
    $col_sets=array();
    $columnNames = array_keys($this->columns);
    // First find the additional plaintext columns we need to add
    foreach($this->columns as $col => $coldef) {
      if (isset($coldef['on_demand']) && $coldef['on_demand']==="true")
        continue;
      if (substr($col, -10)=='date_start') {
        $prefix=substr($col, 0, strlen($col)-10);
        // check that the report includes date_end and type
        if (in_array($prefix."date_end", $columnNames) && in_array($prefix."date_type", $columnNames)) {
          array_push($col_sets, $prefix);
          if (!in_array($prefix.'date', $columnNames)) {
            $this->columns[$prefix.'date'] = array(
              'display'=>'Date',
              'class'=>'',
              'style'=>'',
              'datatype'=>'date'
            );
          }
          // Hide the internal vague date columns, unless the report explicitly asks for them (in which case
          // autodef will not be true).
          if (!array_key_exists('autodef', $this->columns[$prefix.'date_start']) ||
              $this->columns[$prefix.'date_start']['autodef']==true) {
            $this->columns[$prefix.'date_start']['visible']='false';
          }
          if (!array_key_exists('autodef', $this->columns[$prefix.'date_end']) ||
              $this->columns[$prefix.'date_end']['autodef']==true) {
            $this->columns[$prefix.'date_end']['visible']='false';
          }
          if (!array_key_exists('autodef', $this->columns[$prefix.'date_type']) ||
              $this->columns[$prefix.'date_type']['autodef']==true) {
            $this->columns[$prefix.'date_type']['visible']='false';
          }
        }
      }
    }

    // Now we have identified the vague date columns to add, create data columns with the processed date
    // strings.
    $dataCount = count($data); // invariant
    foreach($col_sets as $col_set) {
      for ($r=0; $r<$dataCount; $r++) {
        $row=$data[$r];
        $data[$r][$col_set.'date'] = vague_date::vague_date_to_string(array(
          $row[$col_set.'date_start'],
          $row[$col_set.'date_end'],
          $row[$col_set.'date_type']
        ));
      }
    }
  }

  public function merge_attribute_data(&$data, $providedParams)
  {
    $dataCount = count($data); // invariant
    /* attributes are extra pieces of information associated with data rows. These can have multiple values within each field,
     * so do not lend themselves to being fetched by a extended join within the original SQL query.
     */
    /* loop through each table, looking for attribute definitions */
    $attributeDefns = $this->reportReader->getAttributeDefns();
    /* Attribute definitions included the query to run, and the field names to compare between each data array for matching */
    $vagueDateProcessing = $this->getVagueDateProcessing();
    foreach($attributeDefns as $attributeDefn){
        // Build an index of the report data indexed on the attribute: nb that the attribute data has been sorted in main_id order.
        $index = array();
        for ($r=0; $r<$dataCount; $r++) {
          if(!isset($index[$data[$r][$attributeDefn->parentKey]])){
            $index[$data[$r][$attributeDefn->parentKey]] = array($r);
          } else
            $index[$data[$r][$attributeDefn->parentKey]][] = $r;
        }
    	$subquery = $attributeDefn->query;
        foreach ($providedParams as $name => $value)
        {
          $subquery = preg_replace("/#$name#/", $value, $subquery);
        }
        $response = $this->reportDb->query($subquery);
        $attrData = $response->result_array(FALSE);
        $newColumns = array();
        // This makes some assumptions about the way the attribute data is stored within the DB tables.
        // Note that $attributeDefn->id is actually text, which means that the order of data in $row is actually the order in which the 
        // attributes are encountered in the data set.
        // we assume that the attributes are ordered in blocks of each attribute ID, in the order that we wish them to appear in the report.
        foreach ($attrData as $row){
          // If this attribute row has not been encountered so far, make a new column for it, initialise to blank.
          if(!array_key_exists($row[$attributeDefn->id], $newColumns)){  // id is the column holding the attribute id.
            $newColName=$attributeDefn->columnPrefix.$row[$attributeDefn->id];
            $multiValue = ($row['multi_value'] == 't') && ($row["data_type"] != 'D') && ($row["data_type"] != 'V');
            $newColumns[$row[$attributeDefn->id]] = array(
                  'caption' => $row[$attributeDefn->caption],
                  'column' => $newColName,
                  'multi_value' => $multiValue);
            switch ($row["data_type"]) {
              case 'D':
              case 'V':
                $this->columns[$newColName."_date_start"] = array('display'=>$row[$attributeDefn->caption]." Start", 'class'=>'', 'style'=>'', 'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'));
                $this->columns[$newColName."_date_end"] = array('display'=>$row[$attributeDefn->caption]." End", 'class'=>'', 'style'=>'', 'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'));
                $this->columns[$newColName."_date_type"] = array('display'=>$row[$attributeDefn->caption]." Type", 'class'=>'', 'style'=>'', 'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'));
                if($vagueDateProcessing){  // if vague date processing enable for the report, add the extra column.
                  $this->columns[$newColName."_date"] = array('display'=>$row[$attributeDefn->caption]." Date", 'class'=>'', 'style'=>'');
                }
                for ($r=0; $r<$dataCount; $r++) {
                  $data[$r][$newColName.'_date_start'] = '';
                  $data[$r][$newColName.'_date_end'] = '';
                  $data[$r][$newColName.'_date_type'] = '';
                  $data[$r][$newColName.'_date'] = '';
                }
                break;
              case 'L':
                // Lookup
                if(isset($attributeDefn->meaningIdLanguage))
                  $termResponse = $this->reportDb->query("select tt.meaning_id as id, t.term from terms t, termlists_terms tt, languages l".
                  										 " where tt.termlist_id =".$row["termlist_id"].
                  										 " and tt.term_id = t.id ".
                  										 " and t.language_id = l.id ".
                  										 " and t.deleted=FALSE ".
                  										 " and tt.deleted = FALSE ".
                  										 " and l.deleted=FALSE ".
                  										 ($attributeDefn->meaningIdLanguage== "preferred" ?
                  											" and tt.preferred = true " :
                  											" and l.iso = '".$attributeDefn->meaningIdLanguage."'").
                  										 "ORDER by tt.meaning_id;");
                else
                  $termResponse = $this->reportDb->query("select tt.id, t.term from terms t, termlists_terms tt where tt.termlist_id =".$row["termlist_id"]." and tt.term_id = t.id and t.deleted=FALSE and tt.deleted = FALSE ORDER by tt.id;");
                $newColumns[$row[$attributeDefn->id]]['lookup'] = $termResponse->result_array(FALSE);
                // allow follow through so Lookup follows normal format of a singular field.
              default:
                $this->columns[$newColName] = array('display'=>$row[$attributeDefn->caption], 'class'=>'', 'style'=>'');
                for ($r=0; $r<$dataCount; $r++) {
                  $data[$r][$newColName] = $multiValue ? array() : '';
                }
                break;
            }
          }
          $column = $newColumns[$row[$attributeDefn->id]]['column'];
          switch ($row["data_type"]) {
            case 'L':
              $value = $row['int_value']; // default value is int value
              foreach($newColumns[$row[$attributeDefn->id]]['lookup'] as $lookup){
                if($value == $lookup["id"]){
                  $value = $lookup['term'];
                  break;
                }
              }
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $value);
              break;
            case 'I':
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $row['int_value']);
              break;
            case 'B':
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $row['int_value'] ? 'Yes' : 'No');
              break;
            case 'F':
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $row['float_value']);
              break;
            case 'T':
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $row['text_value']);
              break;
            case 'D':
            case 'V': // assume no multi values: would be far too complex to deal with...
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r){
                  $data[$r][$column."_date_start"] = $row['date_start_value'];
                  $data[$r][$column."_date_end"] = $row['date_end_value'];
                  $data[$r][$column."_date_type"] = $row['date_type_value'];
                }
              break;
          }
        }
        for ($r=0; $r<$dataCount; $r++) {
          foreach($newColumns as $newCol){
            $column = $newCol['column'];
            if($newCol['multi_value'] == true && is_array($data[$r][$column])){
              $data[$r][$column] = implode($attributeDefn->separator, $data[$r][$column]);
            }
          }
        }
    }
  }

  private function mergeColumnData(&$data, $value){
    if(is_array($data)){
      $data[] = $value;
    } else {
      $data = $value;
    }
  }

  /* The following function is the only method by which the reports can update the contents of the database. As a consequence
   * the following restrictions are enforced:
   * 1) the updates are not data driven. The only thing updated is the downloaded column in the occurrences table, and this
   *    is hardcoded.
   *
   */
  private function setDownloaded($data, $downloadDetails)
  {
    if($downloadDetails->mode == 'INITIAL' || $downloadDetails->mode == 'FINAL') {
      $idList = array();
      foreach($data as $row){
        if(isset($row[$downloadDetails->id])){
          $idList[] = $row[$downloadDetails->id];
          if(count($idList) >= self::rowsPerUpdate){
            $this->updateDownloaded($idList, $downloadDetails->mode);
            $idList = array();
          }
        }
      }
      $this->updateDownloaded($idList, $downloadDetails->mode);
    }
  }

  private function updateDownloaded($idList, $mode)
  {
    if(!is_array($idList) || count($idList) == 0)
      return;
    if($mode != 'INITIAL' && $mode != 'FINAL') {
      return;
    }
    $downloaded_on = date("Ymd H:i:s");
    $db = new Database(); // use default access so can update.
    $db->query('START TRANSACTION READ WRITE;');
    $response = $db->in("id", $idList)->where("downloaded_flag", ($mode == 'FINAL'? 'I' : 'N'))
        ->update('occurrences',
          array('downloaded_flag' => ($mode == 'FINAL'? 'F' : 'I'),
              'downloaded_on' => $downloaded_on,
              'updated_on' => $downloaded_on));
    $response = $db->in("id", $idList)->where("downloaded_flag", ($mode == 'FINAL'? 'I' : 'N'))
        ->update('cache_occurrences',
          array('downloaded_flag' => ($mode == 'FINAL'? 'F' : 'I')));
    $db->query('COMMIT;');
  }

  private function fetchLocalReport($request)
  {
    $this->report = null;
    if (is_file($this->localReportDir.'/'.$request)) {
      $this->report = $this->localReportDir.'/'.$request;
      Kohana::log('debug', "Setting local report ".$this->report.".");
    } else {
      foreach (Kohana::config('config.modules') as $path) {
        if (is_file("$path/reports/$request")) {
          $this->report = "$path/reports/$request";
          break;
        }
      }
    }
    if ($this->report===null)
      throw new exception("Unable to find report $request.");    
  }

  private function fetchRemoteReport($request)
  {
    $this->report = $request;
  }

  private function fetchProvidedReport($request)
  {
    // $request here stores the report itself - we save it to a temporary place.
    $uploadDir = $this->localReportDir.'/tmp/';
    if (is_dir($uploadDir))
    {
      $fname = time();
      switch ($this->reportFormat)
      {
  case 'xml':
    $fname .= '.xml';
    break;
  default:
    // Bad stuff
    // TODO
      }
      if (file_put_contents($uploadDir.$fname, $request))
        $this->report = $uploadDir.$fname;
      else {
  // Error - unable to write to temp dir.
  // TODO
      }
    }
    else
    {
      // Unable to cache the report - could try other things, but nah.
    }
  }

  private function cacheReport()
  {
    $cachedReport = Array
    (
    'reportReader' => $this->reportReader,
    'providedParams' => $this->providedParams,
    'expectedParams' => $this->expectedParams,
    'specialParams' =>
        Array('limit' => $this->limit,
              'offset' => $this->offset,
              'orderby' => $this->orderby,
              'sortdir' => $this->sortdir)
    );

    // Set the object in the cache
    $uid = md5(time().rand());
    $this->cache = new Cache;
    $this->cache->set($uid, $cachedReport, array('report'), 3600);
    return $uid;
  }

  private function retrieveCachedReport($cacheid)
  {
    $this->cache = new Cache;
    if ($a = $this->cache->get($cacheid))
    {
      $this->reportReader = $a['reportReader'];
      $this->providedParams = $a['providedParams'];
      $this->expectedParams = $a['expectedParams'];
      $this->limit = $a['specialParams']['limit'];
      $this->offset = $a['specialParams']['offset'];
      $this->orderby = $a['specialParams']['orderby'];
      $this->sortdir = $a['specialParams']['sortdir'];
      
      return true;
    }
    else
    {
      // Cache has timed out / bad UID
      return false;
    }

  }

  private function mergeQuery()
  {
    // Grab the query from the report reader
    $query = $this->reportReader->getQuery();
    $this->query = $this->mergeQueryWithParams($query);
    $this->reportReader->applyPrivilegesFilters($this->query, $this->websiteIds, $this->providedParams['training'], $this->sharingMode, $this->userId);
  }
  
  private function mergeCountQuery()
  {
    // Grab the query from the report reader
    $query = $this->reportReader->getCountQuery();
    if ($query!==null) {
      $this->countQuery = $this->mergeQueryWithParams($query, true);
      $this->reportReader->applyPrivilegesFilters($this->countQuery, $this->websiteIds, $this->providedParams['training'], $this->sharingMode, $this->userId);
    } else 
      $this->countQuery = null;
  }
  
  private function mergeQueryWithParams($query, $counting=false)
  {
    // Replace each parameter in place
    $paramDefs = $this->reportReader->getParams();
    // Pre-parse joins defined by parameters, so that join SQL also gets other parameter values
    // inserted
    foreach ($this->providedParams as $name => $value)
    {
      if (isset($paramDefs[$name])) {
        if (array_key_exists('joins', $paramDefs[$name]))
          $query = $this->addParamJoins($query, $name, $paramDefs[$name], $value);
        if (array_key_exists('wheres', $paramDefs[$name]))
          $query = $this->addParamWheres($query, $name, $paramDefs[$name], $value);
      }
    }
    // Now loop through the joins to insert the values into the query
    foreach ($this->providedParams as $name => $value)
    {
      if (isset($paramDefs[$name])) {
        if ($value==='') {
          $empty = isset($paramDefs[$name]['emptyvalue']) ? $paramDefs[$name]['emptyvalue'] : '';
          // empty integer params should be handled as 0 (null would be ideal, but we can't test for it in the same fashion as a number).
          $query = preg_replace("/#$name#/", $empty, $query);
        }
        else {
          if ($paramDefs[$name]['datatype']=='idlist')
            // idlist is a special parameter type which creates an IN (...) clause. Lets you optionally provide a list
            // of ids for a report.
            $query = preg_replace("/#$name#/", "AND ".$paramDefs[$name]['fieldname']." IN ($value)", $query);
          elseif ($paramDefs[$name]['datatype']=='excludeidlist')
            $query = preg_replace("/#$name#/", "AND ".$paramDefs[$name]['fieldname']." NOT IN ($value)", $query);
          elseif ($paramDefs[$name]['datatype']=='smpattrs')
            $query = $this->mergeAttrListParam($query, 'sample', $value);
          elseif ($paramDefs[$name]['datatype']=='occattrs')
            $query = $this->mergeAttrListParam($query, 'occurrence', $value);
          elseif ($paramDefs[$name]['datatype']=='locattrs')
            $query = $this->mergeAttrListParam($query, 'location', $value);
          elseif ($paramDefs[$name]['datatype']=='taxattrs')
            $query = $this->mergeAttrListParam($query, 'taxa_taxon_list', $value);
          elseif ($paramDefs[$name]['datatype']=='psnattrs')
            $query = $this->mergeAttrListParam($query, 'person', $value);
          else {
            $query = preg_replace("/#$name#/", $value, $query);
          }
        }
      }      
      elseif (isset($this->customAttributes[$name])) {
        // request includes a custom attribute column being used as a filter.
        $field=$this->customAttributes[$name]['field'];
        $query = str_replace('#filters#', "AND $field=$value\n#filters#", $query);
      }
      elseif (isset($this->reportReader->filterableColumns[$name])) {
        $field = $this->reportReader->filterableColumns[$name]['sql'];
        $filterClause = $this->getFilterClause($field, $this->reportReader->filterableColumns[$name]['datatype'], $operator, $value);
        $query = str_replace('#filters#', "AND $filterClause\n#filters#", $query);
      }
      elseif (preg_match('/(?P<prefix>.*)date$/', $name, $matches) 
          && array_key_exists($matches['prefix'].'date_start', $this->reportReader->columns)
          && array_key_exists($matches['prefix'].'date_end', $this->reportReader->columns)
          && array_key_exists($matches['prefix'].'date_type', $this->reportReader->columns)) {
        // special handling for a filter on a vague date added column
        $field = $this->reportReader->columns[$matches['prefix'].'date_start']['sql'];
        $filterClause = $this->getFilterClause($field, 'date', $operator, $value);
        $query = str_replace('#filters#', "AND $filterClause\n#filters#", $query);
      }
    }
    // column replacements and additional join to samples for geometry permissions autoswitching
    if ($this->sharingMode==='me' || $this->sharingMode==='verification') {
      // don't add the join to samples when it is not necessary.
      if (strpos($query, '#sample_sref_field#') || strpos($query, '#sample_geom_field#')) 
        $query = str_replace('#joins#', "JOIN samples s on s.id=o.sample_id AND s.deleted=false \n#joins#", $query);
      $query = str_replace(array('#sample_sref_field#', '#sample_geom_field#'), array('s.entered_sref', 's.geom'), $query);
    } else {
      $query = str_replace(array('#sample_sref_field#', '#sample_geom_field#'), array('o.public_entered_sref', 'o.public_geom'), $query);
    }
    // remove the marker left in the query to show where to insert joins
    $query = str_replace(array('#joins#','#fields#','#group_bys#','#filters#','#idlist#'), array('','','',''), $query);
    // allow the URL to provide a sort order override
    if (!$counting) {
      // prioritise any URL provided sort order, but still keep any other sort ordering in the report.
      $order_by=$this->reportReader->getOrderClause();
      if($order_by){
        if (isset($this->orderby))
          $order_by = $this->orderby . (isset($this->sortdir) ? ' '.$this->sortdir : '') . ', ' . $order_by;
      } else if (isset($this->orderby))
          $order_by = $this->orderby . (isset($this->sortdir) ? ' '.$this->sortdir : '');
      if ($order_by) {
        $order_by = $this->checkOrderByForVagueDate($order_by);
        // Order by will either be appended to the end of the query, or inserted at a #order_by# marker.
        $count=0;
        $query = preg_replace("/#order_by#/",  "ORDER BY $order_by", $query, -1, $count);
        if ($count==0) {
          $query .= " ORDER BY $order_by";
        }
      } else {
        $query = preg_replace("/#order_by#/",  "", $query);
      }
      if (isset($this->limit))
        $query .= ' LIMIT '.$this->limit;
      if ($this->offset)
        $query .= ' OFFSET '.$this->offset;
    } else {
      $query = preg_replace("/#order_by#/",  "", $query);
    }
    return $query;
  }
  
  private function getFilterClause($field, $datatype, &$operator, &$value) {
    if ($datatype=='text') {
      // quote text values and replace * wildcards with SQL friendly ones.
      $value=str_replace('*','%',$value);
      //by default add a wildcard to the end
      if (substr($value, -1)!=='%')
        $value .= '%';
      $operator='ILIKE';
    } else 
      $operator = '='; 
    
    if ($datatype!=='text' && $datatype!=='date') {
      //strip spaces so the user can be more flexible about spaces they enter
      //Note: Don't use this for text filter as spacing might be important for the search.
      //For dates, spacing will be handled by the vague date engine
      $value = str_replace(" ","",$value);
      //apart from text and date values we handle the case where the user enters a range e.g. 1-3
      // @todo: is there an i18n consideration here with the .?
      if (preg_match('/(?P<from>\d+(\.\d+)?)(-|to)(?<to>\d+(\.\d+)?)/', $value, $matches))
        return "$field BETWEEN ".$matches['from']." AND ".$matches['to'];
      // support <, <=, >, >= operators
      if (preg_match('/(?P<op>(>|<|>=|<=))(?P<val>\d+(\.\d+)?)/', $value, $matches)) 
        return "$field ".$matches['op']." ".$matches['val'];
    } 
    if ($datatype=='text') {
      // ensure value is escaped for apostrophes
      $value = pg_escape_string($value);
      // quote text and date values 
      $value="'".$value."'";
    }
    if ($datatype != 'date') {
      return "$field $operator $value";}
    else {
      $vaguedate = vague_date::string_to_vague_date($value);
      return "($field >= '".$vaguedate[0]."' AND $field <= '".$vaguedate[1]."')";
    }
  }

  /**
   * When a parameter is found which defines a list of additional custom attributes to add to a report,
   * this method merges the parameter information into the query, adding in joins and fields to return the
   * selected attributes.
   * @param string $query SQL query to process
   * @param string $type Either occurrence, location or sample depending on the type of attributes being loaded.
   * @param string $attrList parameter value, which should be a comma separated list of attribute IDs or attribute names.
   * @return string Processed query.
   */
  private function mergeAttrListParam($query, $type, $attrList) {
    $this->reportDb
        ->select('distinct a.id, a.data_type, a.caption, a.validation_rules, a.system_function')
        ->from("{$type}_attributes as a");
    if ($this->websiteIds)
      $this->reportDb
          ->join("{$type}_attributes_websites as aw", "aw.{$type}_attribute_id", 'a.id')
          ->join('index_websites_website_agreements as wa', 'wa.from_website_id', 'aw.website_id')
          ->in('wa.to_website_id', $this->websiteIds)
          ->where(array('wa.provide_for_'.$this->sharingMode=>'t', 'aw.deleted' => 'f'));
    $ids = array();
    $captions = array();
    $sysfuncs = array();
    $attrList = explode(',',$attrList);
    $allSurveyAttrs=false;
    foreach($attrList as $attr) {
      if (is_numeric($attr))
        $ids[] = $attr;                 // an attribute ID
      elseif ($attr==='#all_survey_attrs' && !empty($this->providedParams['survey_list']))
        $allSurveyAttrs=true;           // requesting all attributes for a single selected survey
      elseif (substr($attr, 0, 1)==='#') 
        $sysfuncs[] = substr($attr, 1); // a system function
      else
        $captions[] = $attr;            // an attribute caption
    }
    if ($allSurveyAttrs) {
      // a request for all attrs in a selected survey can take precedence over the rest.
      $this->reportDb->in('aw.restrict_to_survey_id', explode(',', $this->providedParams['survey_list']));
      // always exclude email & cms_user_id to keep it private
      $this->reportDb->notin('system_function', array('email','cms_user_id'));
    } else {
      if ((count($ids)===0 ? 0 : 1) + (count($captions)===0 ? 0 : 1) + (count($sysfuncs)===0 ? 0 : 1) > 1)
        throw new exception('Cannot mix numeric IDs, captions and system functions in the list of requested custom attributes');
      if (count($ids)>0) 
        $this->reportDb->in('a.id', $ids);
      elseif (count($captions)>0) 
        $this->reportDb->in('caption', $captions);
      elseif (count($sysfuncs)>0) 
        $this->reportDb->in('system_function', $sysfuncs);
    }
    $attrs = $this->reportDb->get();
    if (!$allSurveyAttrs && count($sysfuncs)>0)
      $this->processSysfuncAttrs($query, $type, $attrs, $sysfuncs);
    else {
      $usingCaptions=count($captions)>0;
      $this->processStandardAttrs($query, $type, $attrs, $usingCaptions);    
    }
    return $query;
  }
  
  /**
   * Create the joins and column definitions required to support a set of custom attributes
   * added to the report by specifying one or more system functions.
   */
  private function processSysfuncAttrs(&$query, $type, $attrs, $sysfuncs) {
    // first, join in all the attribute tables we need
    $done = array();
    $sysfuncsList = array();    
    foreach($attrs as $attr) {
      // don't duplicate any attributes as the SQL distinct does not force distinct when loading from a view.
      if (in_array($attr->id, $done))
        continue;
      $id = $attr->id;
      $done[]=$id;
      $join = $this->addJoinForAttr($query, $type, $attr, true);
      // keep track of the output fields for each system function
      if (!isset($sysfuncsList[$attr->system_function])) {
        $sysfuncsList[$attr->system_function] = array('fields'=>array(), 'data_types'=>array());
      }
      if ($attr->data_type=='L') {
        // lookups need an extra join and a different output field alias
        $query = str_replace('#joins#', $join." ".(class_exists('cache_builder') ? "cache_termlists_terms" : "list_termlists_terms")." ltt$id ON ltt$id.id=$type$id.int_value\n #joins#", $query);
        $sysfuncsList[$attr->system_function]['fields'][] = "ltt$id.term";
        $datatype='text';
      } else {
        switch($attr->data_type) {
          case 'F' :
            $field = 'float_value';
            $datatype='float';
            break;
          case 'T' :
            $field = 'text_value';
            $datatype='text';
            break;
          case 'D' : case 'V' :
            $field = 'date_start_value';
            $datatype='date';
            break;
          default:
            $field = 'int_value';
            $datatype='int';
        }
        $sysfuncsList[$attr->system_function]['fields'][] = "$type$id.$field";
      }
      // track the list of data types we are using
      if (!in_array($datatype, $sysfuncsList[$attr->system_function]['data_types']))
        $sysfuncsList[$attr->system_function]['data_types'][]=$datatype;
    }
    $modelname = "{$type}_attribute";
    $model = ORM::Factory($modelname, -1);
    $defs = $model->get_system_functions();
    foreach($sysfuncsList as $sysfunc => $metadata) {
      $alias = "attr_$sysfunc";
      $this->attrColumns[$alias] = array(
        'display' => empty($defs[$sysfunc]['friendly']) ? $defs[$sysfunc]['title'] : $defs[$sysfunc]['friendly']
      );
      // If we have a mixed data type list, COALESCE requires that we cast them
      if (count($metadata['data_types'])>1) 
        $fieldlist = 'CAST(' . implode(' AS VARCHAR), CAST(', $metadata['fields']) . ' AS VARCHAR)';
      else
        $fieldlist = implode(', ', $metadata['fields']);
      $query = str_replace('#fields#', ", COALESCE($fieldlist) as $alias#fields#", $query);
      // this field should also be inserted into any group by part of the query
      $query = str_replace('#group_bys#', ", COALESCE($fieldlist)#group_bys#", $query);
    }
  }

  /**
   * Create the joins and column definitions required to support a set of custom attributes
   * added to the report by specifying one or more attributes by ID or caption.
   */
  private function processStandardAttrs(&$query, $type, $attrs, $usingCaptions) {
    $done = array();  
    foreach($attrs as $attr) {
      // don't duplicate any attributes as the SQL distinct does not force distinct when loading from a view.
      if (in_array($attr->id, $done))
        continue;
      $id = $attr->id;
      $done[]=$id;
      $join = $this->addJoinForAttr($query, $type, $attr, false);
      // find the query column(s) required for the attribute
      switch($attr->data_type) {
        case 'F' :
          $cols = array('float_value'=>'');
          break;
        case 'T' :
          $cols = array('text_value'=>'');
          break;
        case 'D' :
          $cols = array('date_start_value'=>'');
          break;
        case 'V' :
          $cols = array('date_start_value'=>'_start','date_end_value'=>'_end','date_type_value'=>'_type');
          break;
        case 'L' :          
          $cols= array('int_value'=>'');
          // lookups will have the join inserted later
          break;
        default:
          $cols = array('int_value'=>'');
      }
      // We use the attribute ID or the attribute caption to create the column alias, depending on how it was requested.
      $uniqueId = $usingCaptions ? preg_replace('/\W/', '_', strtolower($attr->caption)) : $id;
      // create the fields required in the SQL. First the attribute ID. 
      $alias = preg_replace('/\_value$/', '', "attr_id_$type"."_$uniqueId");
      $query = str_replace('#fields#', ", $type$id.id as $alias#fields#", $query);
      // this field should also be inserted into any group by part of the query
      $query = str_replace('#group_bys#', ", $type$id.id#group_bys#", $query);
      // hide the ID column
      $this->attrColumns[$alias] = array(
        'visible' => 'false',
      );
      // then the attribute data col(s).
      foreach($cols as $col=>$suffix) {
        $alias = preg_replace('/\_value$/', '', "attr_$type"."_$uniqueId");
        // vague date cols need to distinguish the different column types.
        if ($attr->data_type=='V') 
          $alias += $col;
        // use the #fields# token in the SQL to work out where to put the field, plus #group_bys# for any grouping
        $query = str_replace('#fields#', ", $type$id.$col as $alias#fields#", $query);
        $query = str_replace('#group_bys#', ", $type$id.$col#group_bys#", $query);
        $this->attrColumns[$alias] = array(
          'display' => $attr->caption.$suffix
        );
        // the first column is normally used as the filter.
        $filterCol = $col;
      }
      // add a column to set the caption for vague date processed columns
      if ($attr->data_type=='V') {
        $this->attrColumns["attr_$type"."_$uniqueId".'date'] = array(
          'display' => $attr->caption
        );
      }
      // lookups need special processing for additional joins
      elseif ($attr->data_type=='L') {
        $query = str_replace('#joins#', $join." ".(class_exists('cache_builder') ? "cache_termlists_terms" : "list_termlists_terms")." ltt$id ON ltt$id.id=$type$id.int_value\n #joins#", $query);
        $alias = preg_replace('/\_value$/', '', "attr_$type"."_term_$uniqueId");
        $query = str_replace('#fields#', ", ltt$id.term as $alias#fields#", $query);
        $query = str_replace('#group_bys#', ", ltt$id.term#group_bys#", $query);
        $this->attrColumns["attr_$type"."_term_$uniqueId"] = array(
          'display' => $attr->caption
        );
      }
      // keep a list of the custom attribute columns with a link to the fieldname to filter against, if this column
      // gets used in a filter
      $this->customAttributes["attr_$type"."_$uniqueId"] = array(
        'field' => "$type$id.$filterCol"
      );
      // if we know an attribute caption, we want to be able to lookup the ID.
      $this->customAttributeCaptions["$type:".$attr->caption] = $id;
    }
  }
  
  /**
   * Adds the join required for a custom attribute to the query.
   */
  private function addJoinForAttr(&$query, $type, $attr, $forceOuter) {
    $id = $attr->id;
    // can only use an inner join for definitely required fields. If they are required
    // only at the per-survey level, we must use left joins as the survey could vary per record.
    $join = (strpos($attr->validation_rules, 'required')===false || $forceOuter) ? 'LEFT JOIN' : 'JOIN';
    // find out what alias and field name the query uses for the table & field we need to join to
    // (samples.id, occurrences.id or locations.id).
    $rootIdAttr = inflector::plural($type).'_id_field';
    $rootId = $this->reportReader->$rootIdAttr;
    // construct a join to the attribute values table so we can get the value out.
    $query = str_replace('#joins#', "$join ".$type."_attribute_values $type$id ON $type$id.".$type."_id=$rootId AND $type$id.".$type."_attribute_id=$id AND $type$id.deleted=false\n #joins#", $query);
    return $join;
  }
  
  /**
   * Add any joins defined by a used parameter to the query.
   */
  private function addParamJoins($query, $paramName, $paramDef, $value) {
    $joins = array();
    foreach($paramDef['joins'] as $joinDef) {
      if ((!empty($joinDef['operator']) && (($joinDef['operator']==='equal' && $joinDef['value']===$value) ||
          ($joinDef['operator']==='notequal' && $joinDef['value']!==$value)))
          // operator not provided, so default is to join if param not empty (null string passed for empty integers)
          || (empty($joinDef['operator']) && !empty($value) && $value!=="null")) {
        // Join SQL can contain the parameter value as well.
        $joins[] = str_replace("#$paramName#", $value, $joinDef['sql']);
      }
    }
    // put the param joins after the #joins# token, as we might insert other joins first that are required by the param joins, 
    // e.g. the sample table when doing geometry autoswitching.
    $query = str_replace('#joins#', "#joins#\n".implode("\n", $joins), $query);
    return $query;
  }
  
  /**
   * Add any where clause filters defined by a used parameter to the query.
   * @todo: Consider caching of the preprocess output.
   */
  private function addParamWheres($query, $paramName, $paramDef, $value) {
    if (!empty($paramDef['preprocess']) && !empty($value) && $value!=="null") {
      // use a preprocessing query to calculate the actual param value to use
      $prequery = str_replace("#$paramName#", $value, $paramDef['preprocess']);
      $output = $this->reportDb->query($prequery)->result_array(FALSE);
      $value = implode(',', $output[0]);
    }
    foreach($paramDef['wheres'] as $whereDef) {
      if ((!empty($whereDef['operator']) && (($whereDef['operator']==='equal' && $whereDef['value']===$value) ||
          ($whereDef['operator']==='notequal' && $whereDef['value']!==$value)))
          // operator not provided, so default is to join if param not empty (null string passed for empty integers)
          || (empty($whereDef['operator']) && !empty($value) && $value!=="null")) {
        // Join SQL can contain the parameter value as well.
        $filter = str_replace("#$paramName#", $value, $whereDef['sql']);
        $query = str_replace('#filters#', "AND $filter\n#filters#", $query);
      }
    }
    return $query;
  }
  
  /**
   * If sorting on the date column (the extra column added by vague date processing) then
   * switch the sort order back to use date_start.
   */
  private function checkOrderByForVagueDate($order_by) {
    if ($this->getVagueDateProcessing()) {      
      $tokens = explode(' ', $order_by);
      $this->prepareColumns();
      if (count($tokens)>0) {
        $sortfield = $tokens[0];
        $cols = array_keys($this->columns);
        // First find the additional plaintext columns we need to add
        for ($i=0; $i<count($cols); $i++) {
          if (substr(($cols[$i]), -10)=='date_start') {
            $prefix=substr($cols[$i], 0, strlen($cols[$i])-10);
            if ($sortfield==$prefix.'date') {
              // switch sort to date start
              $tokens[0]=$cols[$i];
              $order_by=implode(' ', $tokens);
              break; // from loop
            }
          }
        }
      }
    }
    return $order_by;
  }

  private function executeQuery()
  {    
    Kohana::log('debug', "Running report query : ".$this->query);
    $tm = microtime(true);
    $this->response = $this->reportDb->query($this->query);
    $tm = microtime(true) - $tm;  
    if ($tm>5) {
      kohana::log('alert', "Report query took $tm seconds.");
      kohana::log('alert', $this->report);
      kohana::log('alert', $this->query);    
    }
  }

}