<?php

/**
 * Indicia, the OPAL Online Recording Toolkit.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/gpl.html.
 *
 * @author Indicia Team
 * @license http://www.gnu.org/licenses/gpl.html GPL
 * @link https://github.com/indicia-team/warehouse
 */

/**
 * Report Engine.
 *
 * The report engine allows for accession of predefined or provided reports.
 */

/**
 * Class to control accession to reports generated by the Indicia core.
 *
 * A report will have a number of parameters that need to be completed by the
 * requester. Because this interface is designed to be used by both the core
 * module and the site module, we cannot directly request this information. As
 * such, we do the following:
 * <ol>
 * <li> Grab the report and parse it for parameters. </li>
 * <li> Send a response back to the requester, inviting them to fill in the
 * parameters. This reponse will include the id generated in step 3. </li>
 * <li> The requester sends back the requested parameters, which are checked
 * against the cache to ensure they're all there. If not, repeat these steps.
 * </li>
 * <li> The core reparses the report, merges the parameters in and executes the
 * query against the core database. Results are formatted and returned to the
 * requester. </li>
 * </ol>
 *
 * We should also allow submission of parameters with the report, or a
 * combination of this and requesting them as we go.
 *
 * We use XML reports roughly in keeping with the standard defined in Recorder
 * (though with limited complexity compared to recorder's options). However,
 * this module is written to easily allow reports written in other formats, and
 * in keeping with the rest of the project we use JSON as our principal language
 * for network communication - e.g. for parameter requests, delivery, and other
 * messages.
 */
class ReportEngine {

  const ROWSPERUPDATE = 50;
  private $report;
  private $reportFormat;
  private $response;

  /**
   * Query string.
   *
   * @var string
   */
  private $query;


  /**
   * Count query string.
   *
   * @var string
   */
  private $countQuery;

  private $reportReader;
  private $expectedParams;
  private $providedParams;
  private $localReportDir;
  private $websiteIds;
  private $userId = NULL;
  private $sharingMode = 'reporting';
  private $doneStandardParamJoins = [];

  /**
   * Database connection for reports.
   *
   * @var Database
   */
  private $reportDb;

  /**
   * List of filters to put in HAVING.
   *
   * @var array
   */
  private $having = [];

  /**
   * A list of additional columns identified from custom attribute parameters.
   *
   * @var array
   */
  private $attrColumns = [];

  /**
   * A list of the actual custom attributes, along with a link to the cols they include.
   *
   * @var array
   */
  private $customAttributes = [];

  /**
   * Count of records in result. Cached to save running query twice.
   *
   * @var int
   */
  private $recordCountResult;

  /**
   * List of reports that have been explicitly authorised.
   *
   * Reports may have an attribute restricted="true", in which case they are
   * only available if explicitly authorised by the REST API for an
   * authenticated client.
   *
   * @var array
   */
  private $authorisedReports = [];

  /**
   * Column definitions loaded for the report.
   *
   * @var array
   */
  private $columns;

  /**
   * Limit if specified as a report parameter.
   *
   * @var int
   */
  private $limit;

  /**
   * Offset if specified as a report parameter.
   *
   * @var int
   */
  private $offset;

  /**
   * Sort direction (ASC|DESC) if specified as a report parameter.
   *
   * @var string
   */
  private $sortdir;

  /**
   * Order by fields if specified as a report parameter.
   *
   * @var string
   */
  private $orderby;

  /**
   * Constructor.
   *
   * @param array $websiteIds
   *   List of websites you are loading the report for. Normally a single, but
   *   can be a list when logged in on the warehouse.
   * @param int $userId
   *   ID of the user loading the report.
   * @param object $db
   *   Database object to run the report. Default null, which will create a new
   *   connection using the report user configuration.
   */
  public function __construct(array $websiteIds = NULL, $userId = NULL, $db = NULL) {
    if ($websiteIds) {
      warehouse::validateIntArray($websiteIds);
    }
    $this->websiteIds = $websiteIds;
    $this->userId = $userId;
    $this->localReportDir = Kohana::config('indicia.localReportDir');
    $this->reportDb = $db ?? new Database('report');
  }

  /**
   * Retrieve all available reports, as a nested associative array.
   */
  public function reportList() {
    $reports = $this->internalReportList(Kohana::config('indicia.localReportDir'), '/');
    foreach (Kohana::config('config.modules') as $path) {
      if (is_dir("$path/reports")) {
        $reports = array_replace_recursive($reports, $this->internalReportList("$path/reports", '/'));
      }
    }
    return $reports;
  }

  /**
   * Returns true if a report cannot be accessed because it is restricted.
   *
   * @param string $report
   *   Report file path.
   * @param array $metadata
   *   Report metadata.
   *
   * @return bool
   *   True if the report is inaccessible for this request.
   */
  private function isReportRestricted($report, array $metadata) {
    return !empty($metadata['restricted'])
      && $metadata['restricted'] !== 'false'
      && !in_array(ltrim($report, '/'), $this->authorisedReports);
  }

  /**
   * Array sorting function for the list of reports and folders.
   *
   * Sorts by the item title.
   *
   * @param array $obj1
   *   First file or folder in the sort.
   * @param array $obj2
   *   Second file or folder in the sort.
   *
   * @return int
   *   Sort result.
   */
  private static function compareTitles(array $obj1, array $obj2) {
    return strcasecmp($obj1['title'], $obj2['title']);
  }

  private function internalReportList($root, $path) {
    $files = [];
    $fullPath = "$root$path";
    if (!is_dir($fullPath)) {
      throw new Exception("Failed to open reports folder " . $fullPath);
    }
    $dir = opendir($fullPath);

    while (FALSE !== ($file = readdir($dir))) {
      // The following skips the tmp folder in the report root as this is used
      // for provided reports.
      if ($file != '.' && $file != '..' && $file != '.svn' && is_dir("$fullPath$file") &&
          ($file !== 'tmp' || $path !== '/')) {
        $folderInfo = [
          'type' => 'folder',
          'title' => $file,
          'content' => $this->internalReportList($root, "$path$file/"),
        ];
        if (file_exists("$fullPath$file/readme.txt")) {
          $folderInfo['description'] = file_get_contents("$fullPath$file/readme.txt");
        }
        $files[$file] = $folderInfo;
      }
      elseif (substr($file, -4) === '.xml') {
        $metadata = XMLReportReader::loadMetadata("$fullPath$file");
        if ($this->isReportRestricted("$path$file", $metadata)) {
          continue;
        }
        $file = basename($file, '.xml');
        $reportPath = ltrim("$path$file", '/');
        $reportInfo = [
          'type' => 'report',
          'title' => $metadata['title'],
          'description' => $metadata['description'],
          'path' => $reportPath,
        ];
        if (!empty($metadata['standard_params'])) {
          $reportInfo['standard_params'] = $metadata['standard_params'];
        }
        if (!empty($metadata['featured'])) {
          $reportInfo['featured'] = $metadata['featured'];
        }
        if (!empty($metadata['summary'])) {
          $reportInfo['summary'] = $metadata['summary'];
        }
        $files[$file] = $reportInfo;
      }
    }
    closedir($dir);
    uasort($files, ['ReportEngine', 'compareTitles']);
    return $files;
  }

  /**
   * Request the report.
   *
   * Access the report - probably we will use routing to direct /report directly
   * to /report/access We can specify a request in a number of ways:
   * <ul>
   * <li> Predefined report on the core module. </li>
   * <li> Predefined report elsewhere (URI given). </li>
   * <li> Report passed with the query. </li>
   * </ul>
   * We also need to perform authentication at a read level for the data we're
   * trying to access (this might be fun, given the low level that the reports
   * run at).
   *
   * @param string $report
   *   Name of the report file to run.
   * @param string $reportSource
   *   Source of the report, either local or remote.
   * @param string $reportFormat
   *   Format of the report file. Currently only xml report file formats are
   *   supported.
   * @param array $params
   *   Associative array of report parameters.
   * @param bool $resultAsArray
   *   Set to FALSE to return the result as a pg result object rather than an
   *   array.
   */
  public function requestReport($report = NULL,
                                $reportSource = 'local',
                                $reportFormat = NULL,
                                array $params = [],
                                $resultAsArray = TRUE,
                                $descriptionLevel = NULL) {
    $this->reportFormat = $reportFormat;
    $this->providedParams = array_merge(
      ['training' => 'false'],
      $params
    );
    global $remoteAuthUserId;
    $this->providedParams['auth_user_id'] = isset($remoteAuthUserId) ? $remoteAuthUserId : -1;
    // Is the default sharing mode of "reporting" being overridden?
    if (isset($this->providedParams['sharing'])) {
      $this->sharingMode = $this->providedParams['sharing'];
    }
    Kohana::log('debug', "Received request for report: $report, source: $reportSource");
    if ($reportSource == NULL) {
      $reportSource = 'local';
    }
    if ($report == NULL) {
      return [
        'error' => 'Report parameter is NULL',
        'report' => $report,
        'source' => $reportSource,
      ];
    }

    switch ($reportSource) {
      case 'local':
        $this->fetchLocalReport($report);
        break;

      case 'remote':
        $this->fetchRemoteReport($report);
        break;

      case 'provided':
        $this->fetchProvidedReport($report);
        break;

      default:
        return ['error' => 'Invalid report source specified'];
    }

    // Now we switch based on the report format.
    switch ($this->reportFormat) {
      case 'xml':
        // Allow the list of columns to be returned to be passed as a parameter.
        $cols = empty($this->providedParams['columns']) ? [] : explode(',', $this->providedParams['columns']);
        $this->reportReader = new XMLReportReader($this->reportDb, $this->report, $cols);
        $metadata = XMLReportReader::loadMetadata($this->report);
        if ($this->isReportRestricted($report, $metadata)) {
          // Abort as restricted report.
          throw new Exception('Attempt to access unauthorised report', 404);
        }
        $this->reportReader->loadStandardParams($this->providedParams, $this->sharingMode);
        break;

      default:
        return ['error' => 'Unknown report format specified: ' . $this->reportFormat];
      // @todo No known report specified - return some error.
    }
    // What parameters do we expect?
    $this->expectedParams = $this->reportReader->getParams();
    // Some have defaults in the report XML file.
    $this->providedParams = array_merge($this->reportReader->defaultParamValues, $this->providedParams);

    // Special case params for limit, offset, ordeby and sortdir must be
    // checked to prevent SQL injection.
    // Limit and Offset must be integers.
    // Sortdir must be ASC|DESC.
    // Orderby must be a single valid identifer.
    $check_params = [
      'limit' => ['type' => 'int', 'regex' => NULL],
      'offset' => ['type' => 'int', 'regex' => NULL],
      'sortdir' => ['type' => 'str', 'regex' => '/^(ASC|DESC)$/i'],
      'orderby' => ['type' => 'str', 'regex' => '/^[A-Z_][A-Z0-9_]*$/i'],
    ];
    foreach ($check_params as $param => $check) {
      if (isset($this->providedParams[$param])) {
        $value = $this->providedParams[$param];
        $checked_value = security::checkParam($value, $check['type'], $check['regex']);
        if ($checked_value !== FALSE) {
          $this->$param = $param === 'orderby' ? $this->reportDb->escape_identifier($checked_value) : $checked_value;
        }
        else {
          Kohana::log('alert', "Invalid parameter, $param, with value '$value' in request for report, $report.");
          throw new Exception('Invalid request.');
        }
      }
      else {
        // Potential for DoS if limit is NULL and results are massive.
        $this->$param = NULL;
      }
    }

    return [
      'description' => $this->reportReader->describeReport($descriptionLevel ?? ReportReader::REPORT_DESCRIPTION_BRIEF),
      'content' => $this->compileReport($resultAsArray),
    ];
  }

  /**
   * Requests the report's metadata including column and parameter information.
   *
   * @param string $report
   *   Name of the report.
   * @param bool $includeUnusedParameters
   *   Set to true to force all parameters to be included, not just those that
   *   are in use for the current report call.
   *
   * @return array
   *   Report metadata associative array.
   */
  public function requestMetadata($report, $includeUnusedParameters = FALSE) {
    $this->fetchLocalReport($report);
    $this->reportReader = new XMLReportReader($this->reportDb, $this->report);
    $this->providedParams = [];
    if ($includeUnusedParameters) {
      $params = $this->reportReader->getAllParams();
    }
    else {
      $this->reportReader->loadStandardParams($this->providedParams, $this->sharingMode);
      $params = $this->reportReader->getParams();
    }
    $this->prepareColumns();
    $r = [
      'columns' => $this->columns,
      'parameters' => $params,
    ];
    return $r;
  }

  /**
   * Authorise access to a list of restricted reports.
   *
   * If a client's authorisation (e.g. a client project in the RESTful API)
   * authorises any restricted reports then this method can be called to enable
   * access.
   *
   * @param array $reports
   *   List of reports to enable access for, e.g.
   *   `['library/occurrences/list_for_elastic_sensitive.xml']`.
   */
  public function setAuthorisedReports(array $reports) {
    $this->authorisedReports = $reports;
  }

  /**
   * Checks parameters and returns request if they're not all there, else compiles the report.
   *
   * @param bool $resultAsArray
   *   TRUE to return the result as an array, FALSE to return a pg result object
   *   which needs to be iterated (better for large results set since it doesn't
   *   load all data into memory).
   *
   * @return array
   *   Array containing columns and data.
   */
  private function compileReport($resultAsArray) {
    // Do we need any more parameters?
    $unpopulatedParams = array_diff_key($this->expectedParams, $this->providedParams);
    if (isset($this->providedParams['paramsFormExcludes'])) {
      $includedParams = array_diff_key($this->expectedParams,
          array_fill_keys(json_decode($this->providedParams['paramsFormExcludes']), ''),
          // Never ask for params with defaults in the params form.
          $this->reportReader->defaultParamValues);
    }
    if (!empty($unpopulatedParams)) {
      // Send a request for further parameters back to the client. If the
      // request specified the list of parameters to drop in the
      // paramsFormExcludes parameter, then the list of parameters is always the
      // ones that are not excluded. Otherwise the list of parameters is the
      // list of unpopulated parameters.
      $res = ['parameterRequest' => isset($includedParams) ? $includedParams : $unpopulatedParams];
      return $res;
    }
    else {
      // Okay, all the parameters have been provided.
      $this->query = $this->buildQuery();
      if ($this->limit === 0 || $this->limit === '0'
        || (isset($this->recordCountResult) && $this->recordCountResult === 0)
        || (isset($_REQUEST['wantRecords']) && $_REQUEST['wantRecords'] === '0')) {
        // Optimisation for zero limited queries.
        $data = [];
      }
      else {
        $this->executeQuery();
        $data = $this->response;
        if ($resultAsArray) {
          $data = $data->result_array(FALSE);
        }
        else {
          $data = $data->result();
        }
      }
      $this->prepareColumns();
      // If not loading the full array, client will have to process vague dates
      // etc themselves.
      if ($resultAsArray) {
        $this->postProcess($data);
      }
      $r = [
        'columns' => $this->columns,
        'records' => &$data,
      ];
      if (isset($includedParams) && count($includedParams) > 0) {
        $r['parameterRequest'] = $includedParams;
      }
      return $r;
    }
  }

  /**
   * Runs a count query.
   *
   * Can be limited if we only want to know if there are enough records to fill
   * the first page of a grid.
   *
   * @param int $limit
   *   Max records to bother counting.
   *
   * @return int
   *   Record count. FALSE if count not possible.
   */
  public function recordCount(int $limit = 0) {
    if (isset($_REQUEST['knownCount'])) {
      return $_REQUEST['knownCount'];
    }
    elseif (isset($this->recordCountResult)) {
      return $this->recordCountResult;
    }
    elseif (isset($_REQUEST['wantCount']) && $_REQUEST['wantCount'] === '0') {
      // Disable record counting as not wanted.
      return 0;
    }

    // Grab the query from the report reader.
    if ($limit > 0) {
      $countQuery = $this->reportReader->getCountQueryWithRowData();
    }
    else {
      $countQuery = $this->reportReader->getCountQuery();
    }
    if (empty($countQuery)) {
      return FALSE;
    }
    $countQuery = $this->mergeQueryWithParams($countQuery, FALSE);
    $this->reportReader->applyWebsitePermissions(
      $countQuery, $this->websiteIds, $this->providedParams, $this->sharingMode, $this->userId
    );
    // If there is a HAVING clause in the query, then we cannot count
    // aggregate queries in the normal way which is to strip the group by and
    // count the appropriate fields. We have to run the full grouped query
    // with the HAVING clause included, then use a subquery to count the rows.
    if (!empty($this->having)) {
      // If using a filter on an aggregated column we use a HAVING clause, we
      // need to base our count on the rows in the original query. So, grab the
      // main query from the report reader without the ORDER BY.
      $query = $this->buildQuery(FALSE);
      // Apply any limits on the number of records to bother counting.
      $limitClause = empty($limit) ? '' : " LIMIT $limit";
      $innerQuery = preg_replace('/LIMIT \d+/i', '', $query);
      $countQuery = "SELECT COUNT(*) FROM ($innerQuery$limitClause) AS subquery";
    }
    elseif ($limit > 0) {
      // Apply any limits on the number of records to bother counting.
      $countQuery = "SELECT COUNT(*) FROM ($countQuery LIMIT $limit) AS subquery";
    }
    $tm = microtime(TRUE);
    $r = $this->reportDb->query($countQuery)->result_array(FALSE);
    kohana::log('debug', 'Count query: ' . $countQuery);
    $tm = microtime(TRUE) - $tm;
    if ($tm > 5) {
      kohana::log('alert', "Count query took $tm seconds.");
      kohana::log('alert', $this->report);
      kohana::log('alert', $countQuery);
    }
    // Query could return no rows, in which case return zero. Or multiple if
    // counting several UNIONED queries.
    $count = 0;
    foreach ($r as $row) {
      $count += $row['count'];
    }
    // If the count query was unlimited or successfully found all the records
    // we can remember it and the result.
    if ($limit === 0 || $count < $limit) {
      $this->countQuery = $countQuery;
      $this->recordCountResult = $count;
      // Since we've got the count data, we may as well return it.
      $_REQUEST['wantCount'] = '1';
    }
    return $count;
  }

  /**
   * Obtain the set of columns from the report reader on demand, so it is only
   * called once.
   */
  private function prepareColumns() {
    if (!isset($this->columns)) {
      $this->columns = array_merge(
         $this->reportReader->getColumns(),
         $this->attrColumns
      );
    }
  }

  /**
   * Post processing of the report output data.
   *
   * Takes the data and columns lists, and carries out any post query
   * processing. This includes vague date processing, and any other defined by
   * the report reader.
   */
  private function postProcess(&$data) {
    $this->merge_attribute_data($data, $this->providedParams);

    $vagueDateProcessing = $this->getVagueDateProcessing();
    $downloadProcessing = $this->getDownloadDetails();
    if ($vagueDateProcessing) {
      $this->addVagueDates($data);
    }
    if ($downloadProcessing->mode == 'INITIAL' ||
        $downloadProcessing->mode == 'CONFIRM' ||
        $downloadProcessing->mode == 'FINAL') {
      $this->setDownloaded($data, $downloadProcessing);
    }
  }

  private function getVagueDateProcessing() {
    $vagueDateProcessing = $this->reportReader->getVagueDateProcessing();
    foreach ($this->providedParams as $name => $value) {
      if (!is_array($value)) {
        $vagueDateProcessing = preg_replace("/#$name#/", $value ?? '', $vagueDateProcessing);
      }
    }
    return !($vagueDateProcessing == 'false');
  }

  private function getDownloadDetails() {
    $downloadProcessing = $this->reportReader->getDownloadDetails();
    foreach ($this->providedParams as $name => $value) {
      if (!is_array($value)) {
        $downloadProcessing->mode = preg_replace("/#$name#/", $value ?? '', $downloadProcessing->mode);
      }
    }
    return $downloadProcessing;
  }

  /**
   * Adds vague date columns.
   *
   * Takes the data and columns lists, and looks for a vague date column set.
   * If one is found, inserts a new column for the processed date string.
   */
  private function addVagueDates(&$data) {
    $col_sets = [];
    $columnNames = array_keys($this->columns);
    // First find the additional plaintext columns we need to add.
    foreach ($this->columns as $col => $coldef) {
      if (isset($coldef['on_demand']) && $coldef['on_demand'] === 'true') {
        continue;
      }
      if (substr($col, -10) === 'date_start') {
        $prefix = substr($col, 0, strlen($col) - 10);
        // Check that the report includes date_end and type.
        if (in_array($prefix . "date_end", $columnNames) && in_array($prefix . "date_type", $columnNames)) {
          array_push($col_sets, $prefix);
          if (!in_array($prefix . 'date', $columnNames)) {
            $this->columns[$prefix . 'date'] = [
              'display' => 'Date',
              'class' => '',
              'style' => '',
              'datatype' => 'date',
            ];
          }
          // Hide the internal vague date columns, unless the report explicitly
          // asks for them (in which case autodef will not be true).
          if (!array_key_exists('autodef', $this->columns[$prefix . 'date_start']) ||
              $this->columns[$prefix . 'date_start']['autodef'] === TRUE) {
            $this->columns[$prefix . 'date_start']['visible'] = 'false';
          }
          if (!array_key_exists('autodef', $this->columns[$prefix . 'date_end']) ||
              $this->columns[$prefix . 'date_end']['autodef'] === TRUE) {
            $this->columns[$prefix . 'date_end']['visible'] = 'false';
          }
          if (!array_key_exists('autodef', $this->columns[$prefix . 'date_type']) ||
              $this->columns[$prefix . 'date_type']['autodef'] === TRUE) {
            $this->columns[$prefix . 'date_type']['visible'] = 'false';
          }
        }
      }
    }

    // Now we have identified the vague date columns to add, create data columns
    // with the processed date strings.
    $dataCount = count($data);
    foreach ($col_sets as $col_set) {
      for ($r = 0; $r < $dataCount; $r++) {
        $row = $data[$r];
        if (!empty($row[$col_set . 'date_type'])) {
          try {
            $data[$r][$col_set . 'date'] = vague_date::vague_date_to_string([
              $row[$col_set . 'date_start'],
              $row[$col_set . 'date_end'],
              $row[$col_set . 'date_type'],
            ]);
          }
          catch (Exception $e) {
            kohana::log('error', 'Error in report vague date conversion: ' . $e->getMessage());
            $data[$r][$col_set . 'date'] = 'Invalid';
          }
        }
      }
    }
  }

  public function merge_attribute_data(&$data, $providedParams) {
    $dataCount = count($data);
    /* Attributes are extra pieces of information associated with data rows.
     * These can have multiple values within each field, so do not lend
     * themselves to being fetched by an extended join within the original SQL
     * query.
     */
    /* Loop through each table, looking for attribute definitions. */
    $attributeDefns = $this->reportReader->getAttributeDefns();
    /* Attribute definitions included the query to run, and the field names to
    compare between each data array for matching */
    $vagueDateProcessing = $this->getVagueDateProcessing();
    foreach ($attributeDefns as $attributeDefn) {
      // Build an index of the report data indexed on the attribute: nb that the
      // attribute data has been sorted in main_id order.
      $index = [];
      for ($r = 0; $r < $dataCount; $r++) {
        if (!isset($index[$data[$r][$attributeDefn->parentKey]])) {
          $index[$data[$r][$attributeDefn->parentKey]] = [$r];
        }
        else {
          $index[$data[$r][$attributeDefn->parentKey]][] = $r;
        }
      }
      $subquery = $attributeDefn->query;
      foreach ($providedParams as $name => $value) {
        $subquery = preg_replace("/#$name#/", $value, $subquery);
      }
      $response = $this->reportDb->query($subquery);
      $attrData = $response->result_array(FALSE);
      $newColumns = [];
      // This makes some assumptions about the way the attribute data is stored
      // within the DB tables. Note that $attributeDefn->id is actually text,
      // which means that the order of data in $row is actually the order in
      // which the attributes are encountered in the data set. We assume that
      // the attributes are ordered in blocks of each attribute ID, in the order
      // that we wish them to appear in the report.
      foreach ($attrData as $row) {
        // If this attribute row has not been encountered so far, make a new
        // column for it, initialise to blank.
        // Id is the column holding the attribute id.
        if (!array_key_exists($row[$attributeDefn->id], $newColumns)) {
          $newColName = $attributeDefn->columnPrefix . $row[$attributeDefn->id];
          $multiValue = ($row['multi_value'] == 't') && ($row["data_type"] != 'D') && ($row["data_type"] != 'V');
          $newColumns[$row[$attributeDefn->id]] = [
            'caption' => $row[$attributeDefn->caption],
            'column' => $newColName,
            'multi_value' => $multiValue,
          ];
          switch ($row["data_type"]) {
            case 'D':
            case 'V':
              $this->columns[$newColName . "_date_start"] = [
                'display' => $row[$attributeDefn->caption] . " Start",
                'class' => '',
                'style' => '',
                'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'),
              ];
              $this->columns[$newColName . "_date_end"] = [
                'display' => $row[$attributeDefn->caption] . " End",
                'class' => '',
                'style' => '',
                'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'),
              ];
              $this->columns[$newColName . "_date_type"] = [
                'display' => $row[$attributeDefn->caption] . " Type",
                'class' => '',
                'style' => '',
                'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'),
              ];
              // If vague date processing enable for the report, add the extra
              // column.
              if ($vagueDateProcessing) {
                $this->columns[$newColName . "_date"] = [
                  'display' => $row[$attributeDefn->caption] . " Date",
                  'class' => '',
                  'style' => '',
                ];
              }
              for ($r = 0; $r < $dataCount; $r++) {
                $data[$r][$newColName . '_date_start'] = '';
                $data[$r][$newColName . '_date_end'] = '';
                $data[$r][$newColName . '_date_type'] = '';
                $data[$r][$newColName . '_date'] = '';
              }
              break;

            case 'L':
              // Lookup.
              if (isset($attributeDefn->meaningIdLanguage)) {
                $languageOrPreferredFilter = $attributeDefn->meaningIdLanguage === "preferred"
                  ? 'and tt.preferred = true'
                  : 'and l.iso=' . pg_escape_literal($this->reportDb->getLink(), $attributeDefn->meaningIdLanguage);
                $sql = <<<SQL
                  SELECT tt.meaning_id AS id, t.term
                  FROM terms t, termlists_terms tt, languages l
                  WHERE tt.termlist_id=?
                  AND tt.term_id=t.id
                  AND t.language_id=l.id
                  AND t.deleted=FALSE
                  AND tt.deleted = FALSE
                  AND l.deleted=FALSE
                  $languageOrPreferredFilter
                  ORDER by tt.meaning_id;
                SQL;
              }
              else {
                $sql = <<<SQL
                  SELECT tt.id, t.term
                  FROM terms t, termlists_terms tt
                  WHERE tt.termlist_id=?
                  AND tt.term_id = t.id
                  AND t.deleted=FALSE
                  AND tt.deleted = FALSE
                  ORDER by tt.id;
                SQL;
              }
              $termResponse = $this->reportDb->query($sql, [
                $row['termlist_id'],
              ]);
              $newColumns[$row[$attributeDefn->id]]['lookup'] = $termResponse->result_array(FALSE);
              // Allow follow through so Lookup follows normal format of a singular field.
            default:
              $this->columns[$newColName] = [
                'display' => $row[$attributeDefn->caption],
                'class' => '',
                'style' => '',
              ];
              for ($r = 0; $r < $dataCount; $r++) {
                $data[$r][$newColName] = $multiValue ? [] : '';
              }
          }
        }
        $column = $newColumns[$row[$attributeDefn->id]]['column'];
        switch ($row["data_type"]) {
          case 'L':
            // Default value is int value.
            $value = $row['int_value'];
            foreach ($newColumns[$row[$attributeDefn->id]]['lookup'] as $lookup) {
              if ($value == $lookup["id"]) {
                $value = $lookup['term'];
                break;
              }
            }
            if (isset($index[$row[$attributeDefn->main_id]])) {
              foreach ($index[$row[$attributeDefn->main_id]] as $r) {
                $this->mergeColumnData($data[$r][$column], $value);
              }
            }
            break;

          case 'I':
            if (isset($index[$row[$attributeDefn->main_id]])) {
              foreach ($index[$row[$attributeDefn->main_id]] as $r) {
                $this->mergeColumnData($data[$r][$column], $row['int_value']);
              }
            }
            break;

          case 'B':
            if (isset($index[$row[$attributeDefn->main_id]])) {
              foreach ($index[$row[$attributeDefn->main_id]] as $r) {
                $this->mergeColumnData($data[$r][$column], $row['int_value'] ? 'Yes' : 'No');
              }
            }
            break;

          case 'F':
            if (isset($index[$row[$attributeDefn->main_id]])) {
              foreach ($index[$row[$attributeDefn->main_id]] as $r) {
                $this->mergeColumnData($data[$r][$column], $row['float_value']);
              }
            }
            break;

          case 'T':
            if (isset($index[$row[$attributeDefn->main_id]])) {
              foreach ($index[$row[$attributeDefn->main_id]] as $r) {
                $this->mergeColumnData($data[$r][$column], $row['text_value']);
              }
            }
            break;

          case 'D':
          case 'V':
            // Assume no multi values: would be far too complex to deal with.
            if (isset($index[$row[$attributeDefn->main_id]])) {
              foreach ($index[$row[$attributeDefn->main_id]] as $r) {
                $data[$r][$column . "_date_start"] = $row['date_start_value'];
                $data[$r][$column . "_date_end"] = $row['date_end_value'];
                $data[$r][$column . "_date_type"] = $row['date_type_value'];
              }
            }
            break;

        }
      }
      for ($r = 0; $r < $dataCount; $r++) {
        foreach ($newColumns as $newCol) {
          $column = $newCol['column'];
          if ($newCol['multi_value'] == TRUE && is_array($data[$r][$column])) {
            $data[$r][$column] = implode($attributeDefn->separator, $data[$r][$column]);
          }
        }
      }
    }
  }

  private function mergeColumnData(&$data, $value) {
    if (is_array($data)) {
      $data[] = $value;
    }
    else {
      $data = $value;
    }
  }

  /**
   * The following function is the only method by which the reports can update
   * the contents of the database. As a consequence the following restrictions
   * are enforced:
   * 1. The updates are not data driven. The only thing updated is the
   *    downloaded column in the occurrences table, and this is hardcoded.
   */
  private function setDownloaded($data, $downloadDetails) {
    if ($downloadDetails->mode == 'INITIAL' || $downloadDetails->mode == 'FINAL') {
      $idList = [];
      foreach ($data as $row) {
        if (isset($row[$downloadDetails->id])) {
          $idList[] = $row[$downloadDetails->id];
          if (count($idList) >= self::ROWSPERUPDATE) {
            $this->updateDownloaded($idList, $downloadDetails->mode);
            $idList = [];
          }
        }
      }
      $this->updateDownloaded($idList, $downloadDetails->mode);
    }
  }

  private function updateDownloaded($idList, $mode) {
    if (!is_array($idList) || count($idList) == 0) {
      return;
    }
    if ($mode != 'INITIAL' && $mode != 'FINAL') {
      return;
    }
    $downloaded_on = date("Ymd H:i:s");
    // Use default database access to allow updates.
    $db = new Database();
    $db->query('START TRANSACTION READ WRITE;');
    $response = $db->in("id", $idList)->where("downloaded_flag", ($mode == 'FINAL' ? 'I' : 'N'))
      ->update('occurrences',
          [
            'downloaded_flag' => ($mode == 'FINAL' ? 'F' : 'I'),
            'downloaded_on' => $downloaded_on,
            'updated_on' => $downloaded_on,
          ]
        );
    // $response = $db->in("id", $idList)->where("downloaded_flag", ($mode == 'FINAL' ? 'I' : 'N'))
    //  ->update('cache_occurrences',
    //      array('downloaded_flag' => ($mode == 'FINAL' ? 'F' : 'I')));
    $db->query('COMMIT;');
  }

  private function fetchLocalReport($request) {
    $this->report = NULL;
    if (is_file($this->localReportDir . '/' . $request)) {
      $this->report = $this->localReportDir . '/' . $request;
      Kohana::log('debug', "Setting local report " . $this->report . ".");
    }
    else {
      foreach (Kohana::config('config.modules') as $path) {
        if (is_file("$path/reports/$request")) {
          $this->report = "$path/reports/$request";
          break;
        }
      }
    }
    if ($this->report === NULL) {
      throw new exception("Unable to find report $request.", 404);
    }
  }

  private function fetchRemoteReport($request) {
    $this->report = $request;
  }

  private function fetchProvidedReport($request) {
    // $request here stores the report itself - we save it to a temporary place.
    $uploadDir = $this->localReportDir . '/tmp/';
    if (is_dir($uploadDir)) {
      $fname = time();
      switch ($this->reportFormat) {
        case 'xml':
          $fname .= '.xml';
          break;

        default:
          // @todo Handle unsupported report type
      }
      if (file_put_contents($uploadDir . $fname, $request)) {
        $this->report = $uploadDir . $fname;
      }
      else {
        // @todo Error - unable to write to temp dir.
      }
    }
    else {
      // Unable to cache the report - could try other things, but nah.
    }
  }

  /**
   * Perform the build of the main report query.
   */
  private function buildQuery($includeOrderBy = TRUE) {
    // Grab the query from the report reader.
    $query = $this->reportReader->getQuery();
    $query = $this->mergeQueryWithParams($query, $includeOrderBy);
    $this->reportReader->applyWebsitePermissions(
      $query, $this->websiteIds, $this->providedParams, $this->sharingMode, $this->userId
    );
    return $query;
  }

  private function mergeQueryWithParams($query, $includeOrderBy = TRUE) {
    $this->having = [];
    // Replace each parameter in place.
    $paramDefs = $this->reportReader->getParams();
    // Clear the list of standardised parameter joins so we start afresh.
    $this->doneStandardParamJoins = [];
    // Pre-parse joins defined by parameters, so that join SQL also gets other parameter values
    // inserted.
    foreach ($this->providedParams as $name => $value) {
      if (isset($paramDefs[$name])) {
        if (array_key_exists('joins', $paramDefs[$name])) {
          $query = $this->addParamJoins($query, $paramDefs[$name], $value);
        }
        if (array_key_exists('wheres', $paramDefs[$name])) {
          $query = $this->addParamWheres($query, $name, $paramDefs[$name], $value);
        }
      }
    }
    // Now loop through the joins to insert the values into the query.
    // Can't guarentee order of providedParams: need to process *attrs param
    // before any custom attribute filters, specifically need to call
    // mergeAttrListParam before custom attribute filters.
    foreach ($this->providedParams as $name => $value) {
      if (isset($paramDefs[$name])) {
        if ($value === '') {
          $empty = isset($paramDefs[$name]['emptyvalue']) ? $paramDefs[$name]['emptyvalue'] : '';
          // Empty integer params should be handled as 0 (NULL would be ideal,
          // but we can't test for it in the same fashion as a number).
          $query = preg_replace("/#$name#/", $empty, $query);
        }
        else {
          if ($paramDefs[$name]['datatype'] === 'idlist') {
            // idlist is a special parameter type which creates an IN (...)
            // clause. Lets you optionally provide a list of ids for a report.
            $query = preg_replace("/#$name#/", "AND " . $paramDefs[$name]['fieldname'] . " IN ($value)", $query);
          }
          elseif ($paramDefs[$name]['datatype'] === 'excludeidlist') {
            $query = preg_replace("/#$name#/", "AND " . $paramDefs[$name]['fieldname'] . " NOT IN ($value)", $query);
          }
          elseif ($paramDefs[$name]['datatype'] === 'smpattrs') {
            $query = $this->mergeAttrListParam($query, 'sample', $value);
          }
          elseif ($paramDefs[$name]['datatype'] === 'smp2attrs') {
            $query = $this->mergeAttrListParam($query, 'sample', $value, "2");
          }
          elseif ($paramDefs[$name]['datatype'] === 'occattrs') {
            $query = $this->mergeAttrListParam($query, 'occurrence', $value);
          }
          elseif ($paramDefs[$name]['datatype'] === 'occ2attrs') {
            $query = $this->mergeAttrListParam($query, 'occurrence', $value, "2");
          }
          elseif ($paramDefs[$name]['datatype'] === 'locattrs') {
            $query = $this->mergeAttrListParam($query, 'location', $value);
          }
          elseif ($paramDefs[$name]['datatype'] === 'loc2attrs') {
            $query = $this->mergeAttrListParam($query, 'location', $value, "2");
          }
          elseif ($paramDefs[$name]['datatype'] === 'taxattrs') {
            $query = $this->mergeAttrListParam($query, 'taxa_taxon_list', $value);
          }
          elseif ($paramDefs[$name]['datatype'] === 'trmattrs') {
            $query = $this->mergeAttrListParam($query, 'termlists_term', $value);
          }
          elseif ($paramDefs[$name]['datatype'] === 'srvattrs') {
            $query = $this->mergeAttrListParam($query, 'survey', $value);
          }
          elseif ($paramDefs[$name]['datatype'] === 'psnattrs') {
            $query = $this->mergeAttrListParam($query, 'person', $value);
          }
          else {
            // Sanitise.
            if (in_array($paramDefs[$name]['datatype'], ['text', 'string'])) {
              // Ensure value is escaped for apostrophes.
              $value = $this->reportDb->escape_str($value);
            }
            elseif (in_array($paramDefs[$name]['datatype'], ['text[]', 'string[]'])) {
              // Array check on text parameter values.
              if (strlen($value)) {
                $arr = str_getcsv($value, ",", "'");
                foreach ($arr as &$item) {
                  $item = $this->reportDb->escape_str($item);
                }
                $value = "'" . implode("','", $arr) . "'";
              }
            }
            elseif (($paramDefs[$name]['datatype'] === 'integer' ||
                     $paramDefs[$name]['datatype'] === 'float') &&
                     !is_numeric($value)) {
              throw new exception("Invalid numeric parameter value $value for $name");
            }
            elseif ($paramDefs[$name]['datatype'] === 'integer[]' ||
                     $paramDefs[$name]['datatype'] === 'float[]') {
              // Array check on numeric parameter values.
              $arr = explode(',', $value);
              foreach ($arr as $item) {
                if (!is_numeric($item)) {
                  throw new exception("Invalid numeric array parameter value $value");
                }
              }
            }
            elseif ($paramDefs[$name]['datatype'] === 'date' &&
                    preg_match('/^\d\d?[\/\-]\d\d?[\/\-]\d{4}$/', $value)) {
              // Force ISO date for SQL safety.
              // @todo This needs further work for i18n if non-European.
              $date = DateTime::createFromFormat('d/m/Y', $value);
              if (!$date) {
                throw new exception("Invalid date parameter value $value");
              }
              $value = $date->format('Y-m-d');
            }
            else {
              // Datatype not specified, so assume text.
              $value = pg_escape_string($this->reportDb->getLink(), $value);
            }
            if (!empty($paramDefs[$name]['preprocess']) && !empty($value) && $value !== 'NULL') {
              // Ensure the original value can be used as well as the processed
              // value.
              $query = preg_replace("/#$name-unprocessed#/", $value, $query);
              // Preprocessor can be a single query string, or a keyed array of
              // preprocess queries to run.
              $preprocessors = is_array($paramDefs[$name]['preprocess'])
                ? $paramDefs[$name]['preprocess'] : [$name => $paramDefs[$name]['preprocess']];
              // Use each preprocessing query to calculate the actual param
              // value to use.
              $websiteFilter = $this->websiteIds ? implode(',', $this->websiteIds) : 'select id from websites';
              $masterTaxonListId = warehouse::getMasterTaxonListId();
              foreach ($preprocessors as $token => $qry) {
                $prequery = str_replace(
                  ["#$name#", '#website_ids#', '#master_list_id#'],
                  // $value is already escaped.
                  [$value, $websiteFilter, $masterTaxonListId],
                  $qry
                );
                $output = $this->reportDb->query($prequery)->result_array(FALSE);
                $pqValue = count($output) > 0 ? implode(',', $output[0]) : NULL;
                if (empty($pqValue)) {
                  $processedDatatype = $paramDefs[$name]['processed_datatype'] ?? $paramDefs[$name]['datatype'] ?? 'string';
                  // Create a dummy value so as to not cause a syntax error.
                  if (preg_match('/^(integer|float)/', $processedDatatype)) {
                    $pqValue = "-999999";
                  }
                  else {
                    $pqValue = "'-999999'";
                  }
                }
                $query = preg_replace("/#$token#/", $pqValue, $query);
              }
            }
            else {
              $query = preg_replace("/#$name#/", $value, $query);
            }
          }
        }
      }
    }
    foreach ($this->providedParams as $name => $value) {
      if (!isset($paramDefs[$name])) {
        if (isset($this->customAttributes[$name])) {
          $filter = $this->getFilterClause(
            $this->customAttributes[$name]['field'],
            $this->customAttributes[$name]['datatype'],
            $operator,
            $value,
            isset($this->customAttributes[$name]['filterWrapSql']) ? $this->customAttributes[$name]['filterWrapSql'] : NULL
          );
          $query = str_replace('#filters#', "AND $filter\n#filters#", $query);
        }
        elseif (isset($this->reportReader->filterableColumns[$name])) {
          $field = $this->reportReader->filterableColumns[$name]['sql'];
          $filterClause = $this->getFilterClause(
            $field,
            $this->reportReader->filterableColumns[$name]['datatype'],
            $operator,
            $value
          );
          if (isset($this->reportReader->columns[$name]['aggregate'])
              && $this->reportReader->columns[$name]['aggregate'] === 'true') {
            $this->having[] = $filterClause;
          }
          else {
            $query = str_replace('#filters#', "AND $filterClause\n#filters#", $query);
          }
        }
        elseif (preg_match('/(?P<prefix>.*)date$/', $name, $matches)
            && array_key_exists($matches['prefix'] . 'date_start', $this->reportReader->columns)
            && array_key_exists($matches['prefix'] . 'date_end', $this->reportReader->columns)
            && array_key_exists($matches['prefix'] . 'date_type', $this->reportReader->columns)) {
          // Special handling for a filter on a vague date added column.
          $field = $this->reportReader->columns[$matches['prefix'] . 'date_start']['sql'];
          $filterClause = $this->getFilterClause($field, 'date', $operator, $value);
          $query = str_replace('#filters#', "AND $filterClause\n#filters#", $query);
        }
      }
    }
    // Column replacements and additional join to samples for geometry
    // permissions autoswitching.
    if ($this->sharingMode === 'me' ||
        $this->sharingMode === 'verification' ||
        $this->groupAllowsSensitiveAccess()) {
      // Don't add the join to samples when it is not necessary.
      if (strpos($query, '#sample_sref_field#') || strpos($query, '#sample_geom_field#')) {
        $query = str_replace(
          '#joins#',
          "JOIN samples s on s.id=o.sample_id AND s.deleted=false \n#joins#",
          $query);
      }
      $query = str_replace(
        ['#sample_sref_field#', '#sample_geom_field#'],
        ['s.entered_sref', 's.geom'],
        $query);
    }
    else {
      if ($this->reportReader->loadLegacyStandardParamsSet) {
        $query = str_replace(
          ['#sample_sref_field#', '#sample_geom_field#'],
          ['o.public_entered_sref', 'o.public_geom'],
          $query);
      }
      else {
        $query = str_replace(
          ['#sample_sref_field#', '#sample_geom_field#'],
          ['snf.public_entered_sref', 'o.public_geom'],
          $query);
      }
      // Also if the privacy_precision is 0 then hide_sample_as_private gets
      // set, so hide these as well.
      if ($this->reportReader->loadStandardParamsSet === 'samples') {
        $query = str_replace('#filters#', "AND s.hide_sample_as_private<>true\n#filters#", $query);
      }
      elseif ($this->reportReader->loadStandardParamsSet === 'occurrences') {
        $query = str_replace('#filters#', "AND o.hide_sample_as_private<>true\n#filters#", $query);
      }
    }
    $having = empty($this->having) ? '' : "\nHAVING " . implode(' AND ', $this->having);
    // Remove the markers left in the query to show where to insert joins,
    // filters etc. This also sets up the query HAVING clause where relevant.
    $query = str_replace(
      ['#joins#', '#fields#', '#group_bys#', '#having#', '#filters#', '#idlist#'],
      ['', '', '', $having, '', ''],
      $query);
    // Allow the URL to provide a sort order override.
    if ($includeOrderBy) {
      // Prioritise any URL provided sort order, but still keep any other sort
      // ordering in the report.
      $orderBy = $this->reportReader->getOrderClause($this->providedParams);
      if ($orderBy) {
        if (isset($this->orderby)) {
          $orderBy = $this->orderby . (isset($this->sortdir) ? ' ' . $this->sortdir : '') . ', ' . $orderBy;
        }
      }
      elseif (isset($this->orderby)) {
        $orderBy = $this->orderby . (isset($this->sortdir) ? ' ' . $this->sortdir : '');
      }
      if ($orderBy) {
        $orderBy = $this->checkOrderByForVagueDate($orderBy);
        if (stripos($query, 'distinct on') === FALSE) {
          $orderBy = $this->optimiseQueryPlan($orderBy);
        }
        // Order by will either be appended to the end of the query, or inserted
        // at a #order_by# marker.
        $count = 0;
        $query = preg_replace("/#order_by#/", "ORDER BY $orderBy", $query, -1, $count);
        if ($count === 0) {
          $query .= " ORDER BY $orderBy";
        }
      }
      else {
        $query = preg_replace("/#order_by#/", "", $query);
      }
      if (isset($this->limit)) {
        $query .= ' LIMIT ' . $this->limit;
      }
      if ($this->offset) {
        $query .= ' OFFSET ' . $this->offset;
      }
    }
    else {
      $query = preg_replace("/#order_by#/", "", $query);
    }
    return $query;
  }

  /**
   * Query plan optimisations.
   *
   * Forces a switch of query plan to avoid slow queries where the record count
   * is less than the limit, causing a walk through the entire table.
   *
   * If loading the first page of a report grid then the PG query planner may
   * opt to scan an index as it judges the first page of records matching the
   * filter will be found in the first part of the index. If this is a mistake
   * and there aren't enough records to fill the first page the result is a
   * very slow index scan, loading all the records and filtering them until the
   * whole table has been checked. To avoid this, when performing a limited
   * query we use a fairly fast variant on the record count query which only
   * counts up to the number of records on the page. If we discover there
   * aren't enought records for the first page, we change the sort order to
   * confuse the query planner so it can't walk the index. This results in an
   * indexed filter of the records first, followed by a sort, which is much
   * faster.
   *
   * @param string $orderBy
   *   Current query order by setting.
   *
   * @return string
   *   Altered order by query clause.
   *
   * @link http://stackoverflow.com/questions/6037843/extremely-slow-postgresql-query-with-order-and-limit-clauses
   */
  private function optimiseQueryPlan($orderBy) {
    // If we are limited to a relatively few number of records and sorting by
    // o.id.
    if (!empty($this->limit) && $this->limit < 200 && preg_match('/o.id (desc|asc)/i', $orderBy)) {
      $count = FALSE;
      if ((isset($_REQUEST['wantCount']) && $_REQUEST['wantCount'] === '1') || isset($_REQUEST['knownCount'])) {
        // Grab the count now. If less than the limit, we fudge the order by to
        // switch query plan.
        $count = isset($_REQUEST['knownCount']) ? $_REQUEST['knownCount'] : $this->recordCount();
      }
      else {
        // Don't want a full count, but because of high risk of an abort early
        // plan causing a full table scan, do a limited count first to see if
        // more than 1 page of data. Set the limit to twice the requested
        // amount so that we don't get stung if there are just a few records
        // in the filter which are early in the table data.
        $count = $this->recordCount($this->limit * 2);
      }
      if ($count !== FALSE && $count < $this->limit * 2) {
        kohana::log('debug', 'Optimising query plan by changing sort order to o.id+0.');
        return str_replace('.id', '.id+0', $orderBy);
      }
    }
    return $orderBy;
  }

  /**
   * Group sensitive record access check.
   *
   * Returns true if the report is using standard parameters and is limited to a
   * group ID which allows its members to view sensitive records, only if the
   * current user is a group member.
   */
  private function groupAllowsSensitiveAccess() {
    // Basic checks we can perform to avoid unnecessary db access.
    if (!$this->reportReader->loadStandardParamsSet || !$this->userId ||
        (empty($this->providedParams['group_id']) && empty($this->providedParams['implicit_group_id']))) {
      return FALSE;
    }
    $group_id = empty($this->providedParams['group_id']) ?
      $this->providedParams['implicit_group_id'] : $this->providedParams['group_id'];
    // Use the cache to avoid db access.
    $key = "allowSensitiveAccessForGroup-$group_id-$this->userId";
    $cache = new Cache();
    $value = $cache->get($key);
    if ($value === NULL) {
      // This checks both that the group allows full precision viewing, plus
      // that the user is a group member.
      $value = $this->reportDb->select('groups.id')
        ->from('groups')
        ->join('groups_users', 'groups_users.group_id', 'groups.id')
        ->where([
          'group_id' => $group_id,
          'view_full_precision' => 't',
          'groups_users.user_id' => $this->userId,
        ])
        ->get()->count() > 0;
      $cache->set($key, $value);
    }
    return $value;
  }

  /**
   * Retrieve the filter required by a column filter row search.
   */
  private function getFilterClause($field, $datatype, &$operator, &$value, $filterWrapSql = NULL) {
    if ($filterWrapSql === NULL) {
      $filterWrapSql = '#filter#';
    }
    // Ensure filter clause reflects any current parameter values.
    $replacements = [];
    foreach ($this->providedParams as $paramName => $paramVal) {
      if (!is_array($paramVal)) {
        $replacements["/#$paramName#/"] = $paramVal;
      }
    }
    $field = preg_replace(array_keys($replacements), array_values($replacements), $field);
    if ($datatype === 'text' || $datatype === 'species') {
      if ($datatype === 'species') {
        // Skip subgenera from species searches.
        $value = preg_replace('/\(.*?\) /', '', $value);
        $field = "regexp_replace($field, '(\(.*\)|\s)', '', 'g')";
      }
      // Quote text values and replace * wildcards with SQL friendly ones.
      $value = str_replace('*', '%', $value);
      // By default add a wildcard to the end.
      if (substr($value, -1) !== '%') {
        $value .= '%';
      }
      $operator = 'ILIKE';
    }
    else {
      $operator = '=';
    }

    if ($datatype !== 'text' && $datatype !== 'date') {
      // Strip spaces so the user can be more flexible about spaces they enter.
      // Note: Don't use this for text filter as spacing might be important for
      // the search. For dates, spacing will be handled by the vague date
      // engine.
      $value = str_replace(" ", "", $value);
      // Apart from text and date values we handle the case where the user
      // enters a range e.g. 1-3.
      // @todo: is there an i18n consideration here with the .?
      if (preg_match('/(?P<from>\d+(\.\d+)?)(-|to)(?<to>\d+(\.\d+)?)/', $value, $matches)) {
        $filter = "$field BETWEEN " . $matches['from'] . " AND " . $matches['to'];
        return str_replace('#filter#', $filter, $filterWrapSql);
      }
      // Support <, <=, >, >= operators.
      if (preg_match('/(?P<op>(>|<|>=|<=))(?P<val>\d+(\.\d+)?)/', $value, $matches)) {
        $filter = "$field " . $matches['op'] . " " . $matches['val'];
        return str_replace('#filter#', $filter, $filterWrapSql);
      }
    }
    if ($datatype === 'text' || $datatype === 'species') {
      // Ensure value is escaped for apostrophes.
      $value = $this->reportDb->escape_str($value);
      // Quote text and date values.
      $value = "'" . $value . "'";
    }
    if ($datatype === 'integer') {
      if (!preg_match('/^\d+$/', $value)) {
        return 'false';
      }
    }
    if ($datatype === 'date') {
      $vaguedate = vague_date::string_to_vague_date($value);
      $filter = "($field >= '" . $vaguedate[0] . "' AND $field <= '" . $vaguedate[1] . "')";
    }
    else {
      $filter = "$field $operator $value";
    }
    return str_replace('#filter#', $filter, $filterWrapSql);
  }

  /**
   * Merge custom attributes identified in a parameter into the query.
   *
   * When a parameter is found which defines a list of additional custom
   * attributes to add to a report, this method merges the parameter information
   * into the query, adding in joins and fields to return the selected
   * attributes.
   *
   * @param string $query
   *   SQL query to process.
   * @param string $entity
   *   Either occurrence, location or sample depending on the type of attributes
   *   being loaded.
   * @param string $attrList
   *   Parameter value, which should be a comma separated list of attribute IDs
   *   or attribute names.
   * @param string $idx
   *   An optional index number when dealing with parent/child table
   *   arrangements.
   *
   * @return string
   *   Processed query.
   */
  private function mergeAttrListParam($query, $entity, $attrList, $idx = "") {
    $this->reportDb
      ->select('distinct a.id, a.data_type, a.caption, a.validation_rules, a.system_function, a.multi_value, a.allow_ranges')
      ->from("{$entity}_attributes as a");
    if ($entity === 'taxa_taxon_list') {
      // Here we may want to join to taxon_lists_taxa_taxon_list_attributes
      // in order to limit attributes to a taxon list.
    }
    elseif ($entity === 'termlists_term') {
      // Here we may want to join to termlists_termlists_terms_attributes
      // in order to limit attributes to a termlist.
    }
    else {
      if ($this->websiteIds) {
        $websiteIds = implode(',', $this->websiteIds);
        // A 'me' share is basically a subtype of a reporting share mode.
        $sharingMode = $this->sharingMode === 'me' ? 'reporting' : $this->sharingMode;
        $this->reportDb
          ->join("{$entity}_attributes_websites as aw", "aw.{$entity}_attribute_id", 'a.id')
          ->join('index_websites_website_agreements as wa', 'wa.from_website_id', 'aw.website_id', 'LEFT')
          ->where("(wa.to_website_id in ($websiteIds) or wa.to_website_id is NULL)")
          ->where(['aw.deleted' => 'f'])
          ->where("(wa.provide_for_$sharingMode='t' or wa.provide_for_$sharingMode is NULL)");
      }
    }
    $ids = [];
    $captions = [];
    $sysfuncs = [];
    $attrList = explode(',', $attrList);
    $allSurveyAttrs = FALSE;
    // Find an attribute that supports survey filtering as this allows us to
    // retrieve the specific set of attributes for the survey.
    if (!empty($this->providedParams['survey_list'])) {
      $surveys = $this->providedParams['survey_list'];
    }
    elseif (!empty($this->providedParams['surveys'])) {
      $surveys = $this->providedParams['surveys'];
    }
    elseif (!empty($this->providedParams['survey_id'])) {
      $surveys = $this->providedParams['survey_id'];
    }
    else {
      $surveys = FALSE;
    }
    foreach ($attrList as $attr) {
      if (is_numeric($attr)) {
        // An attribute ID.
        $ids[] = $attr;
      }
      elseif ($attr === '#all_survey_attrs' && $surveys) {
        // Requesting all attributes for a single selected survey.
        $allSurveyAttrs = TRUE;
      }
      elseif (substr($attr, 0, 1) === '#') {
        // A system function.
        $sysfuncs[] = substr($attr, 1);
      }
      else {
        // An attribute caption.
        $captions[] = $attr;
      }
    }
    unset($attrList['#all_survey_attrs']);
    // A request for all attrs in a selected survey?
    if ($surveys) {
      if (isset($websiteIds)) {
        $this->reportDb->where("(aw.restrict_to_survey_id in ($surveys) " .
          "or (aw.restrict_to_survey_id is NULL and aw.website_id in ($websiteIds)))");
      }
      else {
        // May have come from warehouse frontend where no website provided, but
        // a survey has been provided. Need attributes_websites table.
        $this->reportDb
          ->join("{$entity}_attributes_websites as aw", "aw.{$entity}_attribute_id", 'a.id')
          ->where(['aw.deleted' => 'f']);
        $this->reportDb->where("aw.restrict_to_survey_id in ($surveys)");
      }
    }
    if ($allSurveyAttrs) {
      // Don't auto include email & cms_user_id to keep it private.
      $this->reportDb->notin('system_function', ['email', 'cms_user_id']);
    }
    else {
      if ((count($ids) === 0 ? 0 : 1) +
          (count($captions) === 0 ? 0 : 1) +
          (count($sysfuncs) === 0 ? 0 : 1) > 1) {
        throw new exception('Cannot mix numeric IDs, captions and system
        functions in the list of requested custom attributes');
      }
      if (count($ids) > 0) {
        $this->reportDb->in('a.id', $ids);
      }
      elseif (count($captions) > 0) {
        $this->reportDb->in('caption', $captions);
      }
      elseif (count($sysfuncs) > 0) {
        $this->reportDb->in('system_function', $sysfuncs);
      }
    }
    $attrs = $this->reportDb->get();
    // We want the attributes to appear in the order they have been provided in
    // the list. Can't do through SQL. Don't sort if getting all: Note that
    // there isn't a sample_method or location_type style restriction on the
    // attributes fetched.
    $newAttrList = [];
    foreach ($attrList as $attrID) {
      foreach ($attrs as $attr) {
        if ((count($ids) > 0 && $attr->id == $attrID) ||
            (count($captions) > 0 && $attr->caption == $attrID) ||
            (count($sysfuncs) > 0 && $attr->system_function == preg_replace('/^#/', '', $attrID))) {
          $newAttrList[] = $attr;
        }
      }
    }
    if (!$allSurveyAttrs) {
      $attrs = $newAttrList;
    }
    if (!$allSurveyAttrs && count($sysfuncs) > 0) {
      $this->processSysfuncAttrs($query, $entity, $attrs, $idx);
    }
    else {
      $usingCaptions = count($captions) > 0;
      $this->processStandardAttrs($query, $entity, $attrs, $usingCaptions, $idx);
    }
    return $query;
  }

  /**
   * Gets a system function field name.
   *
   * Returns the field name that needs to be picked out of the attribute values
   * or terms table for a particular data type.
   *
   * @param string $entity
   *   E.g. occurrence or sample.
   * @param string $sysfunc
   *   Name of the system function, required to build the correct field alias.
   * @param string $dataType
   *   Character identifying the field's type, e.g. L for lookup.
   * @param bool $forceVarchar
   *   Set true if there are mixed datatypes, so non-text will be forced to
   *   varchar.
   *
   * @return string
   *   Field name.
   */
  private function getSysFuncFieldName($entity, $sysfunc, $dataType, $forceVarchar) {
    $suffix = $forceVarchar ? '::varchar' : '';
    switch ($dataType) {
      case 'F':
        return "{$entity}_$sysfunc.float_value$suffix\n";

      case 'I':
        return "{$entity}_$sysfunc.int_value$suffix\n";

      case 'T':
        return "{$entity}_$sysfunc.text_value\n";

      case 'D':
      case 'V':
        return "{$entity}_$sysfunc.date_start_value$suffix\n";

      case 'L':
        return "t{$entity}_$sysfunc.term\n";

      default:
        return "{$entity}_$sysfunc.text_value\n";
    }
  }

  /**
   * Handles processing of a system function attribute.
   *
   * Create the joins and column definitions required to support a set of custom
   * attributes added to the report by specifying one or more system functions.
   *
   * @param string $query
   *   Query string being built, will be modified to add joins and fields.
   * @param string $entity
   *   E.g. occurrence or sample.
   * @param array $attrs
   *   List of attribute definitions loaded.
   * @param string $idx
   *   An optional index number when dealing with parent/child table
   *   arrangements.
   */
  private function processSysfuncAttrs(&$query, $entity, array $attrs, $idx) {
    $sysfuncsList = [];
    // For occurrences or samples reports loaded from the cache tables, we've
    // got the sysfunc columns all ready in the cache. Otherwise we need to join
    // the attribute values in.
    if ($this->reportReader->loadStandardParamsSet === 'occurrences' ||
        $this->reportReader->loadStandardParamsSet === 'samples') {
      foreach ($attrs as $attr) {
        if (!empty($attr->system_function) &&
            !in_array($attr->system_function, $sysfuncsList)) {
          $query = str_replace('#fields#', ", \nattr_$attr->system_function#fields#", $query);
          $query = str_replace('#group_bys#', ", attr_$attr->system_function#group_bys#", $query);
          $sysfuncsList[] = $attr->system_function;
        }
      }
    }
    else {
      // We can't use the cache occurrences or samples table columns.
      // First, join in all the attribute tables we need.
      $done = [];
      $sysfuncsList = [];
      // Find all the system functions in the list of attributes we've been
      // given. Prepare some metadata required for each sys func's set of joins.
      foreach ($attrs as $attr) {
        if (!empty($attr->system_function)) {
          // Don't duplicate any attributes as the SQL distinct does not force
          // distinct when loading from a view. Plus, ignore multi-value
          // attributes as too complex to combine with single value attributes.
          if (in_array($attr->id, $done) || $attr->multi_value === 't') {
            continue;
          }
          $id = $attr->id;
          $done[] = $id;
          if (!isset($sysfuncsList[$attr->system_function])) {
            $sysfuncsList[$attr->system_function] = [
              'ids' => [],
              'hasTerm' => FALSE,
              'idsByDatatype' => [],
            ];
          }
          // Store the ids associated with each sysfunc so we can build the joins.
          $sysfuncsList[$attr->system_function]['ids'][] = $attr->id;
          // If a lookup attribute, then the join for this system function will
          // need to join cache_termlists_terms.
          if ($attr->data_type === 'L') {
            $sysfuncsList[$attr->system_function]['hasTerm'] = TRUE;
          }
          // Store the ids associated with each type of data for each sysfunc
          // so we can efficiently build SQL to output the value.
          if (!isset($sysfuncsList[$attr->system_function]['idsByDatatype'][$attr->data_type])) {
            $sysfuncsList[$attr->system_function]['idsByDatatype'][$attr->data_type] = [];
          }
          $sysfuncsList[$attr->system_function]['idsByDatatype'][$attr->data_type][] = $attr->id;
        }
      }
      foreach ($sysfuncsList as $sysfunc => $metadata) {
        $alias = "attr_$sysfunc";
        $fieldSql = "CASE \n";
        foreach ($metadata['idsByDatatype'] as $data_type => $ids) {
          $ids = implode(',', $ids);
          $fieldSql .= "  WHEN {$entity}_$sysfunc.{$entity}_attribute_id IN ($ids) THEN " .
            $this->getSysFuncFieldName($entity, $sysfunc, $data_type, count($metadata['idsByDatatype']) > 1);
        }
        $fieldSql .= "END";
        $query = str_replace('#fields#', ", \n$fieldSql AS $alias#fields#", $query);
        $query = str_replace('#group_bys#', ", $fieldSql#group_bys#", $query);
        $joinFieldAttr = inflector::plural($entity) . '_id_field';
        $joinToField = $this->reportReader->$joinFieldAttr;
        $ids = implode(',', $metadata['ids']);
        $join = "LEFT JOIN {$entity}_attribute_values {$entity}_$sysfunc ON {$entity}_$sysfunc.{$entity}_id=$joinToField AND {$entity}_$sysfunc.deleted=false " .
          "AND {$entity}_$sysfunc.{$entity}_attribute_id IN ($ids)";
        $query = str_replace('#joins#', "$join\n#joins#", $query);
        if ($metadata['hasTerm']) {
          $join = 'LEFT JOIN ' . (class_exists('cache_builder') ? "cache_termlists_terms" : "list_termlists_terms") .
            " t{$entity}_$sysfunc ON t{$entity}_$sysfunc.id = {$entity}_$sysfunc.int_value";
          $query = str_replace('#joins#', "$join\n#joins#", $query);
        }
      }
    }
  }

  /**
   * Retrieve the columns involved in storing the data for a given attribute, depending on its data type.
   *
   * @return array
   *   Array keyed by list of column names, with qualifying suffix so add to
   *   column caption if there are multiple.
   */
  private function getAttrDataColumns($attr) {
    switch ($attr->data_type) {
      case 'F':
        $cols = ['float_value' => ''];
        break;

      case 'T':
        $cols = ['text_value' => ''];
        break;

      case 'D':
        $cols = ['date_start_value' => ''];
        break;

      case 'V':
        $cols = [
          'date_start_value' => ' start',
          'date_end_value' => ' end',
          'date_type_value' => ' type',
        ];
        break;

      case 'L':
        $cols = ['int_value' => ''];
        // Lookups will have the join inserted later.
        break;

      default:
        $cols = ['int_value' => ''];
    }
    return $cols;
  }

  /**
   * Process the custom attributes which are not system functions.
   *
   * Create the joins and column definitions required to support a set of
   * custom attributes added to the report by specifying one or more attributes
   * by ID or caption.
   */
  private function processStandardAttrs(&$query, $entity, $attrs, $usingCaptions, $idx) {
    $done = [];
    $idx_ = $idx == '' ? '' : $idx . '_';
    // Create an array of fields so we can insert into SQL text in one go at
    // the end.
    $fields = [];
    $groupBys = [];
    $rootTableAliases = [
      'sample' => 'snf',
      'occurrence' => 'onf',
      'taxa_taxon_list' => 'cttl',
    ];
    foreach ($attrs as $attr) {
      // Don't duplicate any attributes as the SQL distinct does not force
      // distinct when loading from a view.
      if (in_array($attr->id, $done)) {
        continue;
      }
      $done[] = $attr->id;
      // We use the attribute ID or the attribute caption to create the unique
      // column alias, depending on how it was requested.
      $uniqueId = $usingCaptions ? preg_replace('/\W/', '_', strtolower($attr->caption)) : $attr->id;

      if (!empty($this->providedParams['useJsonAttributes']) &&
          $this->providedParams['useJsonAttributes'] === '1') {
        $alias = "attr_{$entity}{$idx}_$uniqueId";
        $this->attrColumns[$alias] = [
          'display' => $attr->caption,
          'datatype' => $this->handleCustomAttributeAs($attr, TRUE),
        ];
        // Add a field to the query to extract the value from JSON.
        $fields[] = "$rootTableAliases[$entity].attrs_json->>'$attr->id' as $alias";
        // Also add a group by to use if this is an aggregate query.
        $groupBys[] = "$rootTableAliases[$entity].attrs_json->>'$attr->id'";
        // Store the info required if we need to filter on this field.
        $this->customAttributes[$alias] = [
          'field' => "$rootTableAliases[$entity].attrs_json->>'$attr->id'::" . $this->handleCustomAttributeAs($attr, TRUE),
          'datatype' => $this->handleCustomAttributeAs($attr, TRUE),
        ];
      }
      else {
        $attrValIdAlias = "attr_id_{$entity}{$idx}_$uniqueId";
        $this->addJoinsForAttr($query, $entity, $attr, $idx);
        // Find the query column(s) required for the attribute.
        $cols = $this->getAttrDataColumns($attr);
        // Find out what query field alias we need to join the attribute to
        // (e.g. s.id for samples, l.id for locations).
        $joinFieldAttr = inflector::plural($entity) . $idx . '_id_field';
        $joinToField = $this->reportReader->$joinFieldAttr;
        // Create the fields required in the SQL. First the attribute value
        // ID(s).
        if ($attr->multi_value === 't') {
          // Use a subquery for multi-value attributes.
          $fields[] = <<<SQL
(
  SELECT string_agg(mv$attrValIdAlias.id::text, ', ')
  FROM {$entity}_attribute_values mv$attrValIdAlias
  WHERE mv$attrValIdAlias.{$entity}_id=$joinToField
  AND mv$attrValIdAlias.{$entity}_attribute_id=$attr->id
  AND deleted = FALSE
) as $attrValIdAlias
SQL;
          // No need to group by this field as it is an aggregate.
        }
        else {
          // Use a field in the joined table for single value attributes.
          $fields[] = "$entity{$idx_}$attr->id.id as $attrValIdAlias";
          // This field should also be inserted into any group by part of the
          // query.
          $groupBys[] = "$entity{$idx_}$attr->id.id";
        }
        // Hide the value ID column.
        $this->attrColumns[$attrValIdAlias] = [
          'visible' => 'false',
        ];
        $doneFilter = FALSE;
        // Now add the attribute data col(s) to the SQL fields.
        foreach ($cols as $col => $captionSuffix) {
          $alias = "attr_{$entity}{$idx}_$uniqueId";
          // Vague date cols need to distinguish the different column types.
          if ($attr->data_type === 'V') {
            $alias .= $col;
          }
          elseif ($attr->data_type === 'L') {
            // Main output column for lookups is an ID column, so clarify the
            // caption to reflect this.
            $captionSuffix .= ' term ID';
          }
          // Work out the field to insert into the query, and potentially the
          // group by if required.
          if ($attr->multi_value === 't') {
            // Multivalue so use a subquery to build a CSV list of the data, no
            // need to group by as this is aggregated.
            $field = "(select string_agg(mv$alias.$col::text, ', ')
  from {$entity}_attribute_values mv$alias
  where mv$alias.{$entity}_id=$joinToField and mv$alias.{$entity}_attribute_id=$attr->id AND deleted = FALSE)";
          }
          elseif ($attr->allow_ranges === 't' && ($attr->data_type === 'I' || $attr->data_type === 'F')) {
            $field = "$entity{$idx_}$attr->id.$col::text || COALESCE(' - ' || $entity{$idx_}$attr->id.upper_value, '')";
            $groupBys[] = $field;
          }
          else {
            $field = "$entity{$idx_}$attr->id.$col";
            $groupBys[] = $field;
          }
          $fields[] = "$field as $alias";

          // For each attribute, use the first column to prepare the SQL
          // required should this column be used in a filter later.
          if (!$doneFilter) {
            $doneFilter = TRUE;
            if ($attr->multi_value === 't') {
              $filterWrapSql = <<<SQL
EXISTS(
  SELECT mv$alias.$col
  FROM {$entity}_attribute_values mv$alias
  WHERE mv$alias.{$entity}_id=$joinToField AND mv$alias.{$entity}_attribute_id=$attr->id
  AND #filter#
  AND mv$alias.deleted = false
)
SQL;
              $this->customAttributes[$alias] = [
                'filterWrapSql' => $filterWrapSql,
                'field' => "mv$alias.$col",
                'datatype' => $this->handleCustomAttributeAs($attr),
              ];
            }
            else {
              // Store the filter for later.
              $this->customAttributes[$alias] = [
                'field' => $field,
                'datatype' => $this->handleCustomAttributeAs($attr),
              ];
            }

          }
          $this->attrColumns[$alias] = [
            'display' => $attr->caption . $captionSuffix,
            'datatype' => $this->handleCustomAttributeAs($attr),
          ];
        }
        // Add a column to set the display date for vague date processed
        // columns. There is no query field as it is calculated.
        if ($attr->data_type === 'V') {
          $this->attrColumns["{$alias}date"] = [
            'display' => $attr->caption,
          ];
        }
        // Lookups need special processing for additional fields to include the
        // term data.
        elseif ($attr->data_type === 'L') {
          $alias = "attr_$entity{$idx}_term_$uniqueId";
          if ($attr->multi_value === 'f') {
            $fields[] = "ltt{$idx_}{$attr->id}.term as $alias";
            $groupBys[] = "ltt{$idx_}{$attr->id}.term#group_bys#";
            $this->customAttributes[$alias] = [
              'field' => $field,
              'datatype' => 'text',
            ];
          }
          else {
            // Multi-value, so use an aggregate to build a CSV list of the
            // terms.
            $field = "(select array_to_string(array_agg(term{$alias}.term), ', ')
  from {$entity}_attribute_values mv$alias
  join cache_termlists_terms term{$alias} on term{$alias}.id=mv$alias.int_value
  where mv$alias.{$entity}_id=$joinToField and mv$alias.{$entity}_attribute_id=$attr->id AND mv$alias.deleted = FALSE)";
            $fields[] = "$field as $alias";
            // Also use an exists subquery to check the multivalue term in the
            // case of filtering against this column.
            $filterWrapSql = <<<SQL
EXISTS(
  SELECT term{$alias}.term
  FROM {$entity}_attribute_values mv$alias
  JOIN cache_termlists_terms term{$alias} on term{$alias}.id=mv$alias.int_value
  WHERE mv$alias.{$entity}_id=$joinToField and mv$alias.{$entity}_attribute_id=$attr->id and #filter#
)
SQL;
            $this->customAttributes["attr_$entity{$idx}_term_$uniqueId"] = [
              'field' => "term{$alias}.term",
              'filterWrapSql' => $filterWrapSql,
              'datatype' => 'text',
            ];
          }
          $this->attrColumns[$alias] = [
            'display' => "$attr->caption term",
            'datatype' => 'text',
          ];
        }
      }
    }
    // Insert all the fields into the right places in the SQL.
    if (!empty($fields)) {
      $list = implode(",\n", $fields);
      $query = str_replace('#fields#', ",\n$list#fields#", $query);
    }
    if (!empty($groupBys)) {
      $list = implode(",\n", $groupBys);
      $query = str_replace('#group_bys#', ",\n$list#group_bys#", $query);
    }
  }

  /**
   * Determine the datatype name for a custom attribute's column.
   *
   * @param object $attr
   *   Custom attribute definition.
   * @param bool $jsonAttrs
   *   Set to true if using the json_attrs fields to output custom attribute
   *   columns.
   *
   * @return string
   *   The name of the data type to use (e.g. text, integer)
   */
  private function handleCustomAttributeAs($attr, $jsonAttrs = FALSE) {
    // Multi-values have to be treated as text as they are several values
    // joined into a string. Similar for range attributes.
    if (($jsonAttrs && $attr->multi_value === 't') || $attr->allow_ranges === 't') {
      return 'text';
    }
    switch ($attr->data_type) {
      case 'I':
      case 'B':
        return 'integer';

      case 'F':
        return 'float';

      case 'D':
      case 'V':
        return 'date';

      case 'L':
        // If not using JSON, then the main attr field is the termlists_term
        // ID so use an integer. A second text field for the term is added
        // separately.
        return $jsonAttrs ? 'text' : 'integer';

      default:
        return 'text';
    }
  }

  /**
   * Adds the join required for a custom attribute to the query.
   *
   * If a single value attribute, adds a join to the attribute values table
   * and the cache_termlists_terms table if it is a lookup attribute. Multi-
   * value attributes use subqueries so don't need joins.
   */
  private function addJoinsForAttr(&$query, $entity, $attr, $idx) {
    // We only need to add a join to the report for single value attributes, as
    // multi-value attributes use a subquery to retrieve the field value.
    if ($attr->multi_value === 'f') {
      $idx_ = $idx == '' ? '' : $idx . '_';
      // Can only use an inner join for definitely required fields. If they are
      // required only at the per-survey level, we must use left joins as the
      // survey could vary per record.
      $joinType = (strpos($attr->validation_rules ?? '', 'required') === FALSE) ? 'LEFT JOIN' : 'JOIN';
      // Find out what alias and field name the query uses for the table &
      // field we need to join to (samples.id, occurrences.id, locations.id
      // taxa_taxon_lists.id, termlists_terms.id, survey.id or person.id).
      $joinFieldAttr = inflector::plural($entity) . $idx . '_id_field';
      $joinToField = $this->reportReader->$joinFieldAttr;
      $avAlias = "$entity{$idx_}$attr->id";
      // Construct a join to the attribute values table so we can get the value
      // out.
      $join = "$joinType {$entity}_attribute_values $avAlias ON $avAlias.{$entity}_id=$joinToField AND $avAlias.{$entity}_attribute_id=$attr->id AND $avAlias.deleted=false";
      if ($attr->data_type === 'L') {
        $join .= "\n$joinType cache_termlists_terms ltt{$idx_}{$attr->id} ON ltt{$idx_}$attr->id.id={$entity}{$idx_}$attr->id.int_value";
      }
      $query = str_replace('#joins#', "$join\n #joins#", $query);
    }
  }

  /**
   * Determines if a param component should be included in the report SQL.
   *
   * Params can have sub-components (joins or where clauses) which have a value
   * and test operator to determine if they should be included in the report
   * SQL query or not.
   *
   * @param array $componentDef
   *   Definition of the join or where clause read from the report XML file.
   * @param mixed $paramValue
   *   Supplied parameter value (if any).
   */
  private function includeParamComponent(array $componentDef, $paramValue) {
    $include = FALSE;
    if (!isset($componentDef['value'])) {
      // If value not qualified in the where definition, any value except
      // empty triggers the inclusion.
      $include = $paramValue !== '' && $paramValue !== "NULL" && $paramValue !== "0";
    }
    else {
      // Value qualified in the definition, so it must match or not match,
      // depending on the operator in the definition.
      if (empty($componentDef['operator']) || $componentDef['operator'] === 'equal') {
        $include = $componentDef['value'] === $paramValue;
      }
      elseif (!empty($componentDef['operator']) && $componentDef['operator'] === 'notequal') {
        $include = $componentDef['value'] !== $paramValue;
      }
    }
    return $include;
  }

  /**
   * Add any joins defined by a used parameter to the query.
   */
  private function addParamJoins($query, $paramDef, $value) {
    $joins = [];
    foreach ($paramDef['joins'] as $joinDef) {
      if ($this->includeParamComponent($joinDef, $value)) {
        if (!empty($joinDef['sql'])) {
          $joins[] = $joinDef['sql'];
        }
        elseif (!empty($joinDef['standard_join']) && !in_array($joinDef['standard_join'], $this->doneStandardParamJoins)) {
          // A parameter can reference a standard join, so that several params
          // can share 1 join to a table rather than join to it multiple times.
          switch ($joinDef['standard_join']) {
            case 'sj_prefcttl':
              // Preferred taxon join for occurrences reports.
              $joins[] = "JOIN cache_taxa_taxon_lists sj_prefcttl ON sj_prefcttl.id=o.preferred_taxa_taxon_list_id";
              break;

            case 'sj_snf':
              // Samples_non_functional join for occurrences reports.
              $joins[] = "JOIN cache_samples_nonfunctional sj_snf ON sj_snf.id=o.sample_id";
              break;

            case 'sj_smp_snf':
              // Samples_non_functional join for samples reports.
              $joins[] = "JOIN cache_samples_nonfunctional sj_snf ON sj_smp_snf.id=s.id";
              break;

            default:
              throw new exception("Unrecognised standard join refered to by report parameter: $joinDef[standard_join]");
          }
          $this->doneStandardParamJoins[] = $joinDef['standard_join'];
        }
      }
    }
    // Put the param joins after the #joins# token, as we might insert other
    // joins first that are required by the param joins, e.g. the sample table
    // when doing geometry autoswitching.
    $query = str_replace('#joins#', "#joins#\n" . implode("\n", $joins), $query);
    return $query;
  }

  /**
   * Add any where clause filters defined by a used parameter to the query.
   */
  private function addParamWheres($query, $paramName, $paramDef, $values) {
    // Multi-select parameter values need to be exploded into a list.
    $valueList = empty($paramDef['multiselect']) ? [$values] : str_getcsv($values, ",", "'");
    // Work out the operation being used.
    if (isset($paramDef['param_op'])) {
      // Handle params that have where clauses linked to different operations.
      // If the parameter name is <name>_context, them the op param is
      // <name>_op_context so we need to do some splicing.
      $paramOpName = preg_match('/_context$/', $paramName)
            ? preg_replace('/_context$/', '_op_context', $paramName)
            : "{$paramName}_op";
      if (empty($this->providedParams[$paramOpName])) {
        throw new Exception("Parameter $paramName needs a parameter $paramOpName to determine the operation.");
      }
      $operation = $this->providedParams[$paramOpName];
      if ($paramDef['param_op'] === 'inOrNotIn') {
        if (!in_array($operation, ['in', 'not in'])) {
          throw new Exception("Invalid value for report parameter $paramOpName: $operation");
        }
      }
      else {
        throw new Exception("Invalid param_op value for report parameter $paramName: $paramDef[param_op]");
      }
    }
    $filterClauses = [];
    // Step through the supplied list of parameter values (normally only 1).
    foreach ($valueList as $value) {
      foreach ($paramDef['wheres'] as $whereDef) {
        if ($this->includeParamComponent($whereDef, $value)) {
          $filterClauses[] = "($whereDef[sql])";
        }
      }
    }
    if (count($filterClauses) > 0) {
      $filterSql = implode(' OR ', $filterClauses);
      if (count($filterClauses) > 1 || (isset($operation) && $operation === 'not in')) {
        // Multiselect with multiple ticked, so OR list wrapped in brackets.
        $filterSql = "($filterSql)";
      }
      if (isset($operation) && $operation === 'not in') {
        // Operation indicates we want the inverse.
        $filterSql = "NOT $filterSql";
      }
      $query = str_replace('#filters#', "AND $filterSql\n#filters#", $query);
    }
    return $query;
  }

  /**
   * Ensure sorts against vague date fields work.
   *
   * If sorting on the date column (the extra column added by vague date
   * processing) then switch the sort order back to use date_start.
   *
   * @param string $orderBy
   *   The current order by fields.
   *
   * @return string
   *   Altered order by fields.
   */
  private function checkOrderByForVagueDate($orderBy) {
    $orderBy = trim($orderBy);
    if ($this->getVagueDateProcessing() && !empty($orderBy)) {
      $this->prepareColumns();
      $cols = array_keys($this->columns);
      // Find if we have a date_start column to switch date sort fields to.
      for ($i = 0; $i < count($cols); $i++) {
        if (substr(($cols[$i]), -10) == 'date_start') {
          // Got a date_start field available in the cols, so switch any date
          // sort fields over.
          $sortfields = explode(',', $orderBy);
          $prefix = substr($cols[$i], 0, strlen($cols[$i]) - 10);
          foreach ($sortfields as &$field) {
            $tokens = explode(' ', $field);
            if (trim($tokens[0], '"') === $prefix . 'date') {
              $tokens[0] = $cols[$i];
              $field = implode(' ', $tokens);
            }
          }
          $orderBy = implode(',', $sortfields);
          break;
        }
      }
    }
    return $orderBy;
  }

  private function executeQuery() {
    $tm = microtime(TRUE);
    $this->response = $this->reportDb->query($this->query);
    $tm = microtime(TRUE) - $tm;
    if ($tm > 5) {
      kohana::log('alert', "Report query took $tm seconds.");
      kohana::log('alert', $this->report);
      kohana::log('alert', $this->query);
    }
    else {
      Kohana::log('debug', "Run report query : " . $this->query);
    }
  }

  /**
   * Accessor for the SQL.
   *
   * @return string
   *   Query SQL.
   */
  public function getQuery() {
    return $this->query;
  }

}
